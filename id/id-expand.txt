#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use caller_utils::sign::{sign_local_rpc, verify_local_rpc};
use hyperprocess_macro::hyperprocess;
use hyperware_process_lib::logging::{init_logging, Level};
use hyperware_process_lib::Address;
struct IdState {}
#[automatically_derived]
impl ::core::default::Default for IdState {
    #[inline]
    fn default() -> IdState {
        IdState {}
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for IdState {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(f, "IdState")
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for IdState {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "IdState",
                false as usize,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for IdState {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<IdState>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = IdState;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct IdState",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    _: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    _serde::__private::Ok(IdState {})
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    _serde::__private::Ok(IdState {})
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "IdState",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<IdState>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
fn make_sign_sys() -> Address {
    Address::new("our", ("sign", "sign", "sys"))
}
const CURRENT_MESSAGE: ::std::thread::LocalKey<
    std::cell::RefCell<Option<hyperware_process_lib::Message>>,
> = {
    #[inline]
    fn __init() -> std::cell::RefCell<Option<hyperware_process_lib::Message>> {
        std::cell::RefCell::new(None)
    }
    unsafe {
        ::std::thread::LocalKey::new(const {
            if ::std::mem::needs_drop::<
                std::cell::RefCell<Option<hyperware_process_lib::Message>>,
            >() {
                |init| {
                    #[thread_local]
                    static VAL: ::std::thread::local_impl::LazyStorage<
                        std::cell::RefCell<Option<hyperware_process_lib::Message>>,
                        (),
                    > = ::std::thread::local_impl::LazyStorage::new();
                    VAL.get_or_init(init, __init)
                }
            } else {
                |init| {
                    #[thread_local]
                    static VAL: ::std::thread::local_impl::LazyStorage<
                        std::cell::RefCell<Option<hyperware_process_lib::Message>>,
                        !,
                    > = ::std::thread::local_impl::LazyStorage::new();
                    VAL.get_or_init(init, __init)
                }
            }
        })
    }
};
fn source() -> hyperware_process_lib::Address {
    CURRENT_MESSAGE
        .with(|cell| {
            cell.borrow()
                .as_ref()
                .expect("No message in current context")
                .source()
                .clone()
        })
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_init_cabi<T: Guest>(arg0: *mut u8, arg1: usize) {
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    T::init(_rt::string_lift(bytes0));
}
pub trait Guest {
    fn init(our: _rt::String);
}
#[doc(hidden)]
pub(crate) use __export_world_id_sys_v0_cabi;
#[allow(dead_code, clippy::all)]
pub mod hyperware {
    pub mod process {
        #[allow(dead_code, clippy::all)]
        pub mod standard {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// ˗ˏˋ ♡ ˎˊ˗
            /// System Types
            /// ˗ˏˋ ♡ ˎˊ˗
            /// JSON is passed over Wasm boundary as a string.
            pub type Json = _rt::String;
            /// In types passed from kernel, node-id will be a valid Kimap entry.
            pub type NodeId = _rt::String;
            /// Context, like a message body, is a protocol-defined serialized byte
            /// array. It is used when building a Request to save information that
            /// will not be part of a Response, in order to more easily handle
            /// ("contextualize") that Response.
            pub type Context = _rt::Vec<u8>;
            pub struct ProcessId {
                pub process_name: _rt::String,
                pub package_name: _rt::String,
                pub publisher_node: NodeId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProcessId {
                #[inline]
                fn clone(&self) -> ProcessId {
                    ProcessId {
                        process_name: ::core::clone::Clone::clone(&self.process_name),
                        package_name: ::core::clone::Clone::clone(&self.package_name),
                        publisher_node: ::core::clone::Clone::clone(&self.publisher_node),
                    }
                }
            }
            impl From<ProcessId> for Vec<u8> {
                fn from(value: ProcessId) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a ProcessId> for Vec<u8> {
                fn from(value: &'a ProcessId) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for ProcessId {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for ProcessId {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProcessId {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "process_name" => _serde::__private::Ok(__Field::__field0),
                                    "package_name" => _serde::__private::Ok(__Field::__field1),
                                    "publisher_node" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"process_name" => _serde::__private::Ok(__Field::__field0),
                                    b"package_name" => _serde::__private::Ok(__Field::__field1),
                                    b"publisher_node" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ProcessId>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProcessId;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProcessId",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProcessId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProcessId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    NodeId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ProcessId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProcessId {
                                    process_name: __field0,
                                    package_name: __field1,
                                    publisher_node: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<NodeId> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "process_name",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "package_name",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "publisher_node",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<NodeId>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("process_name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("package_name")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("publisher_node")?
                                    }
                                };
                                _serde::__private::Ok(ProcessId {
                                    process_name: __field0,
                                    package_name: __field1,
                                    publisher_node: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "process_name",
                            "package_name",
                            "publisher_node",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProcessId",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ProcessId>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProcessId {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProcessId",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "process_name",
                            &self.process_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "package_name",
                            &self.package_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "publisher_node",
                            &self.publisher_node,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for ProcessId {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ProcessId")
                        .field("process-name", &self.process_name)
                        .field("package-name", &self.package_name)
                        .field("publisher-node", &self.publisher_node)
                        .finish()
                }
            }
            pub struct PackageId {
                pub package_name: _rt::String,
                pub publisher_node: NodeId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PackageId {
                #[inline]
                fn clone(&self) -> PackageId {
                    PackageId {
                        package_name: ::core::clone::Clone::clone(&self.package_name),
                        publisher_node: ::core::clone::Clone::clone(&self.publisher_node),
                    }
                }
            }
            impl From<PackageId> for Vec<u8> {
                fn from(value: PackageId) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a PackageId> for Vec<u8> {
                fn from(value: &'a PackageId) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for PackageId {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for PackageId {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PackageId {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "package_name" => _serde::__private::Ok(__Field::__field0),
                                    "publisher_node" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"package_name" => _serde::__private::Ok(__Field::__field0),
                                    b"publisher_node" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PackageId>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PackageId;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PackageId",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PackageId with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    NodeId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct PackageId with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PackageId {
                                    package_name: __field0,
                                    publisher_node: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<NodeId> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "package_name",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "publisher_node",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<NodeId>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("package_name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("publisher_node")?
                                    }
                                };
                                _serde::__private::Ok(PackageId {
                                    package_name: __field0,
                                    publisher_node: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "package_name",
                            "publisher_node",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PackageId",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<PackageId>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PackageId {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PackageId",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "package_name",
                            &self.package_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "publisher_node",
                            &self.publisher_node,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for PackageId {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PackageId")
                        .field("package-name", &self.package_name)
                        .field("publisher-node", &self.publisher_node)
                        .finish()
                }
            }
            pub struct Address {
                pub node: NodeId,
                pub process: ProcessId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Address {
                #[inline]
                fn clone(&self) -> Address {
                    Address {
                        node: ::core::clone::Clone::clone(&self.node),
                        process: ::core::clone::Clone::clone(&self.process),
                    }
                }
            }
            impl From<Address> for Vec<u8> {
                fn from(value: Address) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Address> for Vec<u8> {
                fn from(value: &'a Address) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Address {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Address {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Address {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node" => _serde::__private::Ok(__Field::__field0),
                                    "process" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node" => _serde::__private::Ok(__Field::__field0),
                                    b"process" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Address>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Address;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Address",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    NodeId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Address with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    ProcessId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Address with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Address {
                                    node: __field0,
                                    process: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<NodeId> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<ProcessId> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("node"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<NodeId>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "process",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<ProcessId>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("process")?
                                    }
                                };
                                _serde::__private::Ok(Address {
                                    node: __field0,
                                    process: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["node", "process"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Address",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Address>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Address {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Address",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node",
                            &self.node,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "process",
                            &self.process,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Address {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Address")
                        .field("node", &self.node)
                        .field("process", &self.process)
                        .finish()
                }
            }
            pub struct LazyLoadBlob {
                pub mime: Option<_rt::String>,
                pub bytes: _rt::Vec<u8>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for LazyLoadBlob {
                #[inline]
                fn clone(&self) -> LazyLoadBlob {
                    LazyLoadBlob {
                        mime: ::core::clone::Clone::clone(&self.mime),
                        bytes: ::core::clone::Clone::clone(&self.bytes),
                    }
                }
            }
            impl From<LazyLoadBlob> for Vec<u8> {
                fn from(value: LazyLoadBlob) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a LazyLoadBlob> for Vec<u8> {
                fn from(value: &'a LazyLoadBlob) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for LazyLoadBlob {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for LazyLoadBlob {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for LazyLoadBlob {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "mime" => _serde::__private::Ok(__Field::__field0),
                                    "bytes" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"mime" => _serde::__private::Ok(__Field::__field0),
                                    b"bytes" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<LazyLoadBlob>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = LazyLoadBlob;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct LazyLoadBlob",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Option<_rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct LazyLoadBlob with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct LazyLoadBlob with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(LazyLoadBlob {
                                    mime: __field0,
                                    bytes: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Option<_rt::String>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("mime"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<_rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("bytes"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("mime")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("bytes")?
                                    }
                                };
                                _serde::__private::Ok(LazyLoadBlob {
                                    mime: __field0,
                                    bytes: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["mime", "bytes"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "LazyLoadBlob",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LazyLoadBlob>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for LazyLoadBlob {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "LazyLoadBlob",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "mime",
                            &self.mime,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "bytes",
                            &self.bytes,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for LazyLoadBlob {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("LazyLoadBlob")
                        .field("mime", &self.mime)
                        .field("bytes", &self.bytes)
                        .finish()
                }
            }
            pub struct Capability {
                pub issuer: Address,
                pub params: Json,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Capability {
                #[inline]
                fn clone(&self) -> Capability {
                    Capability {
                        issuer: ::core::clone::Clone::clone(&self.issuer),
                        params: ::core::clone::Clone::clone(&self.params),
                    }
                }
            }
            impl From<Capability> for Vec<u8> {
                fn from(value: Capability) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Capability> for Vec<u8> {
                fn from(value: &'a Capability) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Capability {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Capability {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Capability {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "issuer" => _serde::__private::Ok(__Field::__field0),
                                    "params" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"issuer" => _serde::__private::Ok(__Field::__field0),
                                    b"params" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Capability>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Capability;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Capability",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Address,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Capability with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Json,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Capability with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Capability {
                                    issuer: __field0,
                                    params: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Address> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Json> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("issuer"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Json>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("issuer")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("params")?
                                    }
                                };
                                _serde::__private::Ok(Capability {
                                    issuer: __field0,
                                    params: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["issuer", "params"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Capability",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Capability>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Capability {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Capability",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "issuer",
                            &self.issuer,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "params",
                            &self.params,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Capability {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Capability")
                        .field("issuer", &self.issuer)
                        .field("params", &self.params)
                        .finish()
                }
            }
            pub struct Request {
                /// set in order to inherit lazy-load-blob from parent message, and if
                /// expects-response is none, direct response to source of parent.
                /// also carries forward certain aspects of parent message in kernel,
                /// see documentation for formal spec and examples:
                /// https://docs.rs/hyperware_process_lib/latest/hyperware_process_lib/struct.Request.html
                pub inherit: bool,
                /// if some, request expects a response in the given number of seconds
                pub expects_response: Option<u64>,
                pub body: _rt::Vec<u8>,
                pub metadata: Option<Json>,
                pub capabilities: _rt::Vec<Capability>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Request {
                #[inline]
                fn clone(&self) -> Request {
                    Request {
                        inherit: ::core::clone::Clone::clone(&self.inherit),
                        expects_response: ::core::clone::Clone::clone(
                            &self.expects_response,
                        ),
                        body: ::core::clone::Clone::clone(&self.body),
                        metadata: ::core::clone::Clone::clone(&self.metadata),
                        capabilities: ::core::clone::Clone::clone(&self.capabilities),
                    }
                }
            }
            impl From<Request> for Vec<u8> {
                fn from(value: Request) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Request> for Vec<u8> {
                fn from(value: &'a Request) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Request {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Request {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Request {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "inherit" => _serde::__private::Ok(__Field::__field0),
                                    "expects_response" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    "body" => _serde::__private::Ok(__Field::__field2),
                                    "metadata" => _serde::__private::Ok(__Field::__field3),
                                    "capabilities" => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"inherit" => _serde::__private::Ok(__Field::__field0),
                                    b"expects_response" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"body" => _serde::__private::Ok(__Field::__field2),
                                    b"metadata" => _serde::__private::Ok(__Field::__field3),
                                    b"capabilities" => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Request>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Request;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Request",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    bool,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Option<u64>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Option<Json>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<Capability>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Request {
                                    inherit: __field0,
                                    expects_response: __field1,
                                    body: __field2,
                                    metadata: __field3,
                                    capabilities: __field4,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Option<u64>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<Option<Json>> = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<
                                    _rt::Vec<Capability>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "inherit",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "expects_response",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<u64>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("body"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "metadata",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<Json>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "capabilities",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<Capability>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("inherit")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("expects_response")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("body")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("metadata")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("capabilities")?
                                    }
                                };
                                _serde::__private::Ok(Request {
                                    inherit: __field0,
                                    expects_response: __field1,
                                    body: __field2,
                                    metadata: __field3,
                                    capabilities: __field4,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "inherit",
                            "expects_response",
                            "body",
                            "metadata",
                            "capabilities",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Request",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Request>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Request {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Request",
                            false as usize + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "inherit",
                            &self.inherit,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "expects_response",
                            &self.expects_response,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "body",
                            &self.body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "metadata",
                            &self.metadata,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "capabilities",
                            &self.capabilities,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Request {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Request")
                        .field("inherit", &self.inherit)
                        .field("expects-response", &self.expects_response)
                        .field("body", &self.body)
                        .field("metadata", &self.metadata)
                        .field("capabilities", &self.capabilities)
                        .finish()
                }
            }
            pub struct Response {
                pub inherit: bool,
                pub body: _rt::Vec<u8>,
                pub metadata: Option<Json>,
                pub capabilities: _rt::Vec<Capability>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Response {
                #[inline]
                fn clone(&self) -> Response {
                    Response {
                        inherit: ::core::clone::Clone::clone(&self.inherit),
                        body: ::core::clone::Clone::clone(&self.body),
                        metadata: ::core::clone::Clone::clone(&self.metadata),
                        capabilities: ::core::clone::Clone::clone(&self.capabilities),
                    }
                }
            }
            impl From<Response> for Vec<u8> {
                fn from(value: Response) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Response> for Vec<u8> {
                fn from(value: &'a Response) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Response {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Response {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Response {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "inherit" => _serde::__private::Ok(__Field::__field0),
                                    "body" => _serde::__private::Ok(__Field::__field1),
                                    "metadata" => _serde::__private::Ok(__Field::__field2),
                                    "capabilities" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"inherit" => _serde::__private::Ok(__Field::__field0),
                                    b"body" => _serde::__private::Ok(__Field::__field1),
                                    b"metadata" => _serde::__private::Ok(__Field::__field2),
                                    b"capabilities" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Response>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Response;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Response",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    bool,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Option<Json>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<Capability>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Response {
                                    inherit: __field0,
                                    body: __field1,
                                    metadata: __field2,
                                    capabilities: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Option<Json>> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    _rt::Vec<Capability>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "inherit",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("body"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "metadata",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<Json>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "capabilities",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<Capability>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("inherit")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("metadata")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("capabilities")?
                                    }
                                };
                                _serde::__private::Ok(Response {
                                    inherit: __field0,
                                    body: __field1,
                                    metadata: __field2,
                                    capabilities: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "inherit",
                            "body",
                            "metadata",
                            "capabilities",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Response",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Response>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Response {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Response",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "inherit",
                            &self.inherit,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "body",
                            &self.body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "metadata",
                            &self.metadata,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "capabilities",
                            &self.capabilities,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Response {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Response")
                        .field("inherit", &self.inherit)
                        .field("body", &self.body)
                        .field("metadata", &self.metadata)
                        .field("capabilities", &self.capabilities)
                        .finish()
                }
            }
            /// A message can be a request or a response. Within a response, there is
            /// a result which surfaces any error that happened because of a request.
            /// A successful response will contain the context of the request it
            /// matches, if any was set.
            pub enum Message {
                Request(Request),
                Response((Response, Option<Context>)),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Message {
                #[inline]
                fn clone(&self) -> Message {
                    match self {
                        Message::Request(__self_0) => {
                            Message::Request(::core::clone::Clone::clone(__self_0))
                        }
                        Message::Response(__self_0) => {
                            Message::Response(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl From<Message> for Vec<u8> {
                fn from(value: Message) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Message> for Vec<u8> {
                fn from(value: &'a Message) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Message {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Message {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Message {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "Request" => _serde::__private::Ok(__Field::__field0),
                                    "Response" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"Request" => _serde::__private::Ok(__Field::__field0),
                                    b"Response" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Message>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Message;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum Message",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Request,
                                            >(__variant),
                                            Message::Request,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                (Response, Option<Context>),
                                            >(__variant),
                                            Message::Response,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "Request",
                            "Response",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "Message",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Message>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Message {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            Message::Request(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "Message",
                                    0u32,
                                    "Request",
                                    __field0,
                                )
                            }
                            Message::Response(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "Message",
                                    1u32,
                                    "Response",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            impl ::core::fmt::Debug for Message {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Message::Request(e) => {
                            f.debug_tuple("Message::Request").field(e).finish()
                        }
                        Message::Response(e) => {
                            f.debug_tuple("Message::Response").field(e).finish()
                        }
                    }
                }
            }
            /// On-exit is a setting that determines what happens when a process
            /// panics, completes, or otherwise "ends".
            /// NOTE: requests will always have expects-response set to false by kernel.
            pub enum OnExit {
                None,
                Restart,
                Requests(_rt::Vec<(Address, Request, Option<LazyLoadBlob>)>),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OnExit {
                #[inline]
                fn clone(&self) -> OnExit {
                    match self {
                        OnExit::None => OnExit::None,
                        OnExit::Restart => OnExit::Restart,
                        OnExit::Requests(__self_0) => {
                            OnExit::Requests(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl From<OnExit> for Vec<u8> {
                fn from(value: OnExit) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a OnExit> for Vec<u8> {
                fn from(value: &'a OnExit) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for OnExit {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for OnExit {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for OnExit {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "None" => _serde::__private::Ok(__Field::__field0),
                                    "Restart" => _serde::__private::Ok(__Field::__field1),
                                    "Requests" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"None" => _serde::__private::Ok(__Field::__field0),
                                    b"Restart" => _serde::__private::Ok(__Field::__field1),
                                    b"Requests" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<OnExit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = OnExit;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum OnExit",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(OnExit::None)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(OnExit::Restart)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                _rt::Vec<(Address, Request, Option<LazyLoadBlob>)>,
                                            >(__variant),
                                            OnExit::Requests,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "None",
                            "Restart",
                            "Requests",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "OnExit",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<OnExit>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for OnExit {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            OnExit::None => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "OnExit",
                                    0u32,
                                    "None",
                                )
                            }
                            OnExit::Restart => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "OnExit",
                                    1u32,
                                    "Restart",
                                )
                            }
                            OnExit::Requests(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "OnExit",
                                    2u32,
                                    "Requests",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            impl ::core::fmt::Debug for OnExit {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        OnExit::None => f.debug_tuple("OnExit::None").finish(),
                        OnExit::Restart => f.debug_tuple("OnExit::Restart").finish(),
                        OnExit::Requests(e) => {
                            f.debug_tuple("OnExit::Requests").field(e).finish()
                        }
                    }
                }
            }
            #[repr(u8)]
            pub enum SendErrorKind {
                Offline,
                Timeout,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SendErrorKind {
                #[inline]
                fn clone(&self) -> SendErrorKind {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for SendErrorKind {}
            #[automatically_derived]
            impl ::core::cmp::Eq for SendErrorKind {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for SendErrorKind {
                #[inline]
                fn cmp(&self, other: &SendErrorKind) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SendErrorKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SendErrorKind {
                #[inline]
                fn eq(&self, other: &SendErrorKind) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for SendErrorKind {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &SendErrorKind,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl From<SendErrorKind> for Vec<u8> {
                fn from(value: SendErrorKind) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a SendErrorKind> for Vec<u8> {
                fn from(value: &'a SendErrorKind) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for SendErrorKind {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for SendErrorKind {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SendErrorKind {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "Offline" => _serde::__private::Ok(__Field::__field0),
                                    "Timeout" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"Offline" => _serde::__private::Ok(__Field::__field0),
                                    b"Timeout" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SendErrorKind>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SendErrorKind;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum SendErrorKind",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SendErrorKind::Offline)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SendErrorKind::Timeout)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "Offline",
                            "Timeout",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "SendErrorKind",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SendErrorKind>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SendErrorKind {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            SendErrorKind::Offline => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SendErrorKind",
                                    0u32,
                                    "Offline",
                                )
                            }
                            SendErrorKind::Timeout => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SendErrorKind",
                                    1u32,
                                    "Timeout",
                                )
                            }
                        }
                    }
                }
            };
            impl ::core::fmt::Debug for SendErrorKind {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        SendErrorKind::Offline => {
                            f.debug_tuple("SendErrorKind::Offline").finish()
                        }
                        SendErrorKind::Timeout => {
                            f.debug_tuple("SendErrorKind::Timeout").finish()
                        }
                    }
                }
            }
            impl SendErrorKind {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> SendErrorKind {
                    if !true {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => SendErrorKind::Offline,
                        1 => SendErrorKind::Timeout,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            /// Send errors come from trying to send a message to another process,
            /// either locally or on another node.
            /// A message can fail by timing out, or by the node being entirely
            /// unreachable (offline or can't be found in PKI). In either case,
            /// the message is not delivered and the process that sent it receives
            /// that message back along with any assigned context and/or lazy-load-blob,
            /// and is free to handle it as it sees fit.
            /// In the local case, only timeout errors are possible and also cover the case
            /// in which a process is not running or does not exist.
            pub struct SendError {
                pub kind: SendErrorKind,
                pub target: Address,
                pub message: Message,
                pub lazy_load_blob: Option<LazyLoadBlob>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SendError {
                #[inline]
                fn clone(&self) -> SendError {
                    SendError {
                        kind: ::core::clone::Clone::clone(&self.kind),
                        target: ::core::clone::Clone::clone(&self.target),
                        message: ::core::clone::Clone::clone(&self.message),
                        lazy_load_blob: ::core::clone::Clone::clone(&self.lazy_load_blob),
                    }
                }
            }
            impl From<SendError> for Vec<u8> {
                fn from(value: SendError) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a SendError> for Vec<u8> {
                fn from(value: &'a SendError) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for SendError {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for SendError {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SendError {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "kind" => _serde::__private::Ok(__Field::__field0),
                                    "target" => _serde::__private::Ok(__Field::__field1),
                                    "message" => _serde::__private::Ok(__Field::__field2),
                                    "lazy_load_blob" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"kind" => _serde::__private::Ok(__Field::__field0),
                                    b"target" => _serde::__private::Ok(__Field::__field1),
                                    b"message" => _serde::__private::Ok(__Field::__field2),
                                    b"lazy_load_blob" => {
                                        _serde::__private::Ok(__Field::__field3)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SendError>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SendError;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct SendError",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    SendErrorKind,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Address,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Message,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Option<LazyLoadBlob>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(SendError {
                                    kind: __field0,
                                    target: __field1,
                                    message: __field2,
                                    lazy_load_blob: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    SendErrorKind,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Address> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Message> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    Option<LazyLoadBlob>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("kind"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    SendErrorKind,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "message",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Message>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "lazy_load_blob",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<LazyLoadBlob>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("kind")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("message")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("lazy_load_blob")?
                                    }
                                };
                                _serde::__private::Ok(SendError {
                                    kind: __field0,
                                    target: __field1,
                                    message: __field2,
                                    lazy_load_blob: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "kind",
                            "target",
                            "message",
                            "lazy_load_blob",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "SendError",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SendError>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SendError {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "SendError",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "kind",
                            &self.kind,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "message",
                            &self.message,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lazy_load_blob",
                            &self.lazy_load_blob,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for SendError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SendError")
                        .field("kind", &self.kind)
                        .field("target", &self.target)
                        .field("message", &self.message)
                        .field("lazy-load-blob", &self.lazy_load_blob)
                        .finish()
                }
            }
            impl ::core::fmt::Display for SendError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for SendError {}
            #[repr(u8)]
            pub enum SpawnError {
                NameTaken,
                NoFileAtPath,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SpawnError {
                #[inline]
                fn clone(&self) -> SpawnError {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for SpawnError {}
            #[automatically_derived]
            impl ::core::cmp::Eq for SpawnError {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for SpawnError {
                #[inline]
                fn cmp(&self, other: &SpawnError) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SpawnError {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SpawnError {
                #[inline]
                fn eq(&self, other: &SpawnError) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for SpawnError {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &SpawnError,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl From<SpawnError> for Vec<u8> {
                fn from(value: SpawnError) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a SpawnError> for Vec<u8> {
                fn from(value: &'a SpawnError) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for SpawnError {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for SpawnError {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SpawnError {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "NameTaken" => _serde::__private::Ok(__Field::__field0),
                                    "NoFileAtPath" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"NameTaken" => _serde::__private::Ok(__Field::__field0),
                                    b"NoFileAtPath" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SpawnError>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SpawnError;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum SpawnError",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SpawnError::NameTaken)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SpawnError::NoFileAtPath)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "NameTaken",
                            "NoFileAtPath",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "SpawnError",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SpawnError>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SpawnError {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            SpawnError::NameTaken => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SpawnError",
                                    0u32,
                                    "NameTaken",
                                )
                            }
                            SpawnError::NoFileAtPath => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SpawnError",
                                    1u32,
                                    "NoFileAtPath",
                                )
                            }
                        }
                    }
                }
            };
            impl SpawnError {
                pub fn name(&self) -> &'static str {
                    match self {
                        SpawnError::NameTaken => "name-taken",
                        SpawnError::NoFileAtPath => "no-file-at-path",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        SpawnError::NameTaken => "",
                        SpawnError::NoFileAtPath => "",
                    }
                }
            }
            impl ::core::fmt::Debug for SpawnError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SpawnError")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for SpawnError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.write_fmt(
                        format_args!("{0} (error {1})", self.name(), *self as i32),
                    )
                }
            }
            impl std::error::Error for SpawnError {}
            impl SpawnError {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> SpawnError {
                    if !true {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => SpawnError::NameTaken,
                        1 => SpawnError::NoFileAtPath,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ˗ˏˋ ♡ ˎˊ˗
            /// System Utils
            /// ˗ˏˋ ♡ ˎˊ˗
            /// Prints to the terminal at a given verbosity level.
            /// Higher verbosity levels print more information.
            /// Level 0 is always printed -- use sparingly.
            pub fn print_to_terminal(verbosity: u8, message: &str) {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(_rt::as_i32(&verbosity), ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the address of the process.
            pub fn our() -> Address {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 32]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let len3 = l2;
                    let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
                    let l4 = *ptr0.add(8).cast::<*mut u8>();
                    let l5 = *ptr0.add(12).cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr0.add(16).cast::<*mut u8>();
                    let l8 = *ptr0.add(20).cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let l10 = *ptr0.add(24).cast::<*mut u8>();
                    let l11 = *ptr0.add(28).cast::<usize>();
                    let len12 = l11;
                    let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                    Address {
                        node: _rt::string_lift(bytes3),
                        process: ProcessId {
                            process_name: _rt::string_lift(bytes6),
                            package_name: _rt::string_lift(bytes9),
                            publisher_node: _rt::string_lift(bytes12),
                        },
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ˗ˏˋ ♡ ˎˊ˗
            /// Process Management
            /// ˗ˏˋ ♡ ˎˊ˗
            pub fn get_on_exit() -> OnExit {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let v53 = match l1 {
                        0 => OnExit::None,
                        1 => OnExit::Restart,
                        n => {
                            if true {
                                match (&n, &2) {
                                    (left_val, right_val) => {
                                        if !(*left_val == *right_val) {
                                            let kind = ::core::panicking::AssertKind::Eq;
                                            ::core::panicking::assert_failed(
                                                kind,
                                                &*left_val,
                                                &*right_val,
                                                ::core::option::Option::Some(
                                                    format_args!("invalid enum discriminant"),
                                                ),
                                            );
                                        }
                                    }
                                };
                            }
                            let e53 = {
                                let l2 = *ptr0.add(4).cast::<*mut u8>();
                                let l3 = *ptr0.add(8).cast::<usize>();
                                let base52 = l2;
                                let len52 = l3;
                                let mut result52 = _rt::Vec::with_capacity(len52);
                                for i in 0..len52 {
                                    let base = base52.add(i * 112);
                                    let e52 = {
                                        let l4 = *base.add(0).cast::<*mut u8>();
                                        let l5 = *base.add(4).cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            l4.cast(),
                                            len6,
                                            len6,
                                        );
                                        let l7 = *base.add(8).cast::<*mut u8>();
                                        let l8 = *base.add(12).cast::<usize>();
                                        let len9 = l8;
                                        let bytes9 = _rt::Vec::from_raw_parts(
                                            l7.cast(),
                                            len9,
                                            len9,
                                        );
                                        let l10 = *base.add(16).cast::<*mut u8>();
                                        let l11 = *base.add(20).cast::<usize>();
                                        let len12 = l11;
                                        let bytes12 = _rt::Vec::from_raw_parts(
                                            l10.cast(),
                                            len12,
                                            len12,
                                        );
                                        let l13 = *base.add(24).cast::<*mut u8>();
                                        let l14 = *base.add(28).cast::<usize>();
                                        let len15 = l14;
                                        let bytes15 = _rt::Vec::from_raw_parts(
                                            l13.cast(),
                                            len15,
                                            len15,
                                        );
                                        let l16 = i32::from(*base.add(32).cast::<u8>());
                                        let l17 = i32::from(*base.add(40).cast::<u8>());
                                        let l19 = *base.add(56).cast::<*mut u8>();
                                        let l20 = *base.add(60).cast::<usize>();
                                        let len21 = l20;
                                        let l22 = i32::from(*base.add(64).cast::<u8>());
                                        let l26 = *base.add(76).cast::<*mut u8>();
                                        let l27 = *base.add(80).cast::<usize>();
                                        let base43 = l26;
                                        let len43 = l27;
                                        let mut result43 = _rt::Vec::with_capacity(len43);
                                        for i in 0..len43 {
                                            let base = base43.add(i * 40);
                                            let e43 = {
                                                let l28 = *base.add(0).cast::<*mut u8>();
                                                let l29 = *base.add(4).cast::<usize>();
                                                let len30 = l29;
                                                let bytes30 = _rt::Vec::from_raw_parts(
                                                    l28.cast(),
                                                    len30,
                                                    len30,
                                                );
                                                let l31 = *base.add(8).cast::<*mut u8>();
                                                let l32 = *base.add(12).cast::<usize>();
                                                let len33 = l32;
                                                let bytes33 = _rt::Vec::from_raw_parts(
                                                    l31.cast(),
                                                    len33,
                                                    len33,
                                                );
                                                let l34 = *base.add(16).cast::<*mut u8>();
                                                let l35 = *base.add(20).cast::<usize>();
                                                let len36 = l35;
                                                let bytes36 = _rt::Vec::from_raw_parts(
                                                    l34.cast(),
                                                    len36,
                                                    len36,
                                                );
                                                let l37 = *base.add(24).cast::<*mut u8>();
                                                let l38 = *base.add(28).cast::<usize>();
                                                let len39 = l38;
                                                let bytes39 = _rt::Vec::from_raw_parts(
                                                    l37.cast(),
                                                    len39,
                                                    len39,
                                                );
                                                let l40 = *base.add(32).cast::<*mut u8>();
                                                let l41 = *base.add(36).cast::<usize>();
                                                let len42 = l41;
                                                let bytes42 = _rt::Vec::from_raw_parts(
                                                    l40.cast(),
                                                    len42,
                                                    len42,
                                                );
                                                Capability {
                                                    issuer: Address {
                                                        node: _rt::string_lift(bytes30),
                                                        process: ProcessId {
                                                            process_name: _rt::string_lift(bytes33),
                                                            package_name: _rt::string_lift(bytes36),
                                                            publisher_node: _rt::string_lift(bytes39),
                                                        },
                                                    },
                                                    params: _rt::string_lift(bytes42),
                                                }
                                            };
                                            result43.push(e43);
                                        }
                                        _rt::cabi_dealloc(base43, len43 * 40, 4);
                                        let l44 = i32::from(*base.add(88).cast::<u8>());
                                        (
                                            Address {
                                                node: _rt::string_lift(bytes6),
                                                process: ProcessId {
                                                    process_name: _rt::string_lift(bytes9),
                                                    package_name: _rt::string_lift(bytes12),
                                                    publisher_node: _rt::string_lift(bytes15),
                                                },
                                            },
                                            Request {
                                                inherit: _rt::bool_lift(l16 as u8),
                                                expects_response: match l17 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l18 = *base.add(48).cast::<i64>();
                                                            l18 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l19.cast(), len21, len21),
                                                metadata: match l22 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l23 = *base.add(68).cast::<*mut u8>();
                                                            let l24 = *base.add(72).cast::<usize>();
                                                            let len25 = l24;
                                                            let bytes25 = _rt::Vec::from_raw_parts(
                                                                l23.cast(),
                                                                len25,
                                                                len25,
                                                            );
                                                            _rt::string_lift(bytes25)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result43,
                                            },
                                            match l44 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l45 = i32::from(*base.add(92).cast::<u8>());
                                                        let l49 = *base.add(104).cast::<*mut u8>();
                                                        let l50 = *base.add(108).cast::<usize>();
                                                        let len51 = l50;
                                                        LazyLoadBlob {
                                                            mime: match l45 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l46 = *base.add(96).cast::<*mut u8>();
                                                                        let l47 = *base.add(100).cast::<usize>();
                                                                        let len48 = l47;
                                                                        let bytes48 = _rt::Vec::from_raw_parts(
                                                                            l46.cast(),
                                                                            len48,
                                                                            len48,
                                                                        );
                                                                        _rt::string_lift(bytes48)
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            },
                                                            bytes: _rt::Vec::from_raw_parts(l49.cast(), len51, len51),
                                                        }
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                        )
                                    };
                                    result52.push(e52);
                                }
                                _rt::cabi_dealloc(base52, len52 * 112, 8);
                                result52
                            };
                            OnExit::Requests(e53)
                        }
                    };
                    v53
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn set_on_exit(on_exit: &OnExit) {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    let (result23_0, result23_1, result23_2) = match on_exit {
                        OnExit::None => (0i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Restart => (1i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Requests(e) => {
                            let vec22 = e;
                            let len22 = vec22.len();
                            let layout22 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec22.len() * 112,
                                8,
                            );
                            let result22 = if layout22.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout22).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout22);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec22.into_iter().enumerate() {
                                let base = result22.add(i * 112);
                                {
                                    let (t0_0, t0_1, t0_2) = e;
                                    let Address { node: node1, process: process1 } = t0_0;
                                    let vec2 = node1;
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    *base.add(4).cast::<usize>() = len2;
                                    *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                                    let ProcessId {
                                        process_name: process_name3,
                                        package_name: package_name3,
                                        publisher_node: publisher_node3,
                                    } = process1;
                                    let vec4 = process_name3;
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    *base.add(12).cast::<usize>() = len4;
                                    *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                                    let vec5 = package_name3;
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    *base.add(20).cast::<usize>() = len5;
                                    *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                    let vec6 = publisher_node3;
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    *base.add(28).cast::<usize>() = len6;
                                    *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                                    let Request {
                                        inherit: inherit7,
                                        expects_response: expects_response7,
                                        body: body7,
                                        metadata: metadata7,
                                        capabilities: capabilities7,
                                    } = t0_1;
                                    *base.add(32).cast::<u8>() = (match inherit7 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match expects_response7 {
                                        Some(e) => {
                                            *base.add(40).cast::<u8>() = (1i32) as u8;
                                            *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        None => {
                                            *base.add(40).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec8 = body7;
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    *base.add(60).cast::<usize>() = len8;
                                    *base.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                                    match metadata7 {
                                        Some(e) => {
                                            *base.add(64).cast::<u8>() = (1i32) as u8;
                                            let vec9 = e;
                                            let ptr9 = vec9.as_ptr().cast::<u8>();
                                            let len9 = vec9.len();
                                            *base.add(72).cast::<usize>() = len9;
                                            *base.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                                        }
                                        None => {
                                            *base.add(64).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec18 = capabilities7;
                                    let len18 = vec18.len();
                                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec18.len() * 40,
                                        4,
                                    );
                                    let result18 = if layout18.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout18);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec18.into_iter().enumerate() {
                                        let base = result18.add(i * 40);
                                        {
                                            let Capability { issuer: issuer10, params: params10 } = e;
                                            let Address { node: node11, process: process11 } = issuer10;
                                            let vec12 = node11;
                                            let ptr12 = vec12.as_ptr().cast::<u8>();
                                            let len12 = vec12.len();
                                            *base.add(4).cast::<usize>() = len12;
                                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                                            let ProcessId {
                                                process_name: process_name13,
                                                package_name: package_name13,
                                                publisher_node: publisher_node13,
                                            } = process11;
                                            let vec14 = process_name13;
                                            let ptr14 = vec14.as_ptr().cast::<u8>();
                                            let len14 = vec14.len();
                                            *base.add(12).cast::<usize>() = len14;
                                            *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                                            let vec15 = package_name13;
                                            let ptr15 = vec15.as_ptr().cast::<u8>();
                                            let len15 = vec15.len();
                                            *base.add(20).cast::<usize>() = len15;
                                            *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                            let vec16 = publisher_node13;
                                            let ptr16 = vec16.as_ptr().cast::<u8>();
                                            let len16 = vec16.len();
                                            *base.add(28).cast::<usize>() = len16;
                                            *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                                            let vec17 = params10;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base.add(36).cast::<usize>() = len17;
                                            *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                                        }
                                    }
                                    *base.add(80).cast::<usize>() = len18;
                                    *base.add(76).cast::<*mut u8>() = result18;
                                    match t0_2 {
                                        Some(e) => {
                                            *base.add(88).cast::<u8>() = (1i32) as u8;
                                            let LazyLoadBlob { mime: mime19, bytes: bytes19 } = e;
                                            match mime19 {
                                                Some(e) => {
                                                    *base.add(92).cast::<u8>() = (1i32) as u8;
                                                    let vec20 = e;
                                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                                    let len20 = vec20.len();
                                                    *base.add(100).cast::<usize>() = len20;
                                                    *base.add(96).cast::<*mut u8>() = ptr20.cast_mut();
                                                }
                                                None => {
                                                    *base.add(92).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            let vec21 = bytes19;
                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                            let len21 = vec21.len();
                                            *base.add(108).cast::<usize>() = len21;
                                            *base.add(104).cast::<*mut u8>() = ptr21.cast_mut();
                                        }
                                        None => {
                                            *base.add(88).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    cleanup_list.extend_from_slice(&[(result18, layout18)]);
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result22, layout22)]);
                            (2i32, result22, len22)
                        }
                    };
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result23_0, result23_1, result23_2);
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_state() -> Option<_rt::Vec<u8>> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => None,
                        1 => {
                            let e = {
                                let l2 = *ptr0.add(4).cast::<*mut u8>();
                                let l3 = *ptr0.add(8).cast::<usize>();
                                let len4 = l3;
                                _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn set_state(bytes: &[u8]) {
                unsafe {
                    let vec0 = bytes;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn clear_state() {
                unsafe {
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import();
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn spawn(
                name: Option<&str>,
                wasm_path: &str,
                on_exit: &OnExit,
                request_capabilities: &[Capability],
                grant_capabilities: &[(ProcessId, Json)],
                public: bool,
            ) -> Result<ProcessId, SpawnError> {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 28]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
                    let (result1_0, result1_1, result1_2) = match name {
                        Some(e) => {
                            let vec0 = e;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            (1i32, ptr0.cast_mut(), len0)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    let vec2 = wasm_path;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let (result26_0, result26_1, result26_2) = match on_exit {
                        OnExit::None => (0i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Restart => (1i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Requests(e) => {
                            let vec25 = e;
                            let len25 = vec25.len();
                            let layout25 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec25.len() * 112,
                                8,
                            );
                            let result25 = if layout25.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout25).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout25);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec25.into_iter().enumerate() {
                                let base = result25.add(i * 112);
                                {
                                    let (t3_0, t3_1, t3_2) = e;
                                    let Address { node: node4, process: process4 } = t3_0;
                                    let vec5 = node4;
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    *base.add(4).cast::<usize>() = len5;
                                    *base.add(0).cast::<*mut u8>() = ptr5.cast_mut();
                                    let ProcessId {
                                        process_name: process_name6,
                                        package_name: package_name6,
                                        publisher_node: publisher_node6,
                                    } = process4;
                                    let vec7 = process_name6;
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    *base.add(12).cast::<usize>() = len7;
                                    *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                    let vec8 = package_name6;
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    *base.add(20).cast::<usize>() = len8;
                                    *base.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                    let vec9 = publisher_node6;
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    *base.add(28).cast::<usize>() = len9;
                                    *base.add(24).cast::<*mut u8>() = ptr9.cast_mut();
                                    let Request {
                                        inherit: inherit10,
                                        expects_response: expects_response10,
                                        body: body10,
                                        metadata: metadata10,
                                        capabilities: capabilities10,
                                    } = t3_1;
                                    *base.add(32).cast::<u8>() = (match inherit10 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match expects_response10 {
                                        Some(e) => {
                                            *base.add(40).cast::<u8>() = (1i32) as u8;
                                            *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        None => {
                                            *base.add(40).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec11 = body10;
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    *base.add(60).cast::<usize>() = len11;
                                    *base.add(56).cast::<*mut u8>() = ptr11.cast_mut();
                                    match metadata10 {
                                        Some(e) => {
                                            *base.add(64).cast::<u8>() = (1i32) as u8;
                                            let vec12 = e;
                                            let ptr12 = vec12.as_ptr().cast::<u8>();
                                            let len12 = vec12.len();
                                            *base.add(72).cast::<usize>() = len12;
                                            *base.add(68).cast::<*mut u8>() = ptr12.cast_mut();
                                        }
                                        None => {
                                            *base.add(64).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec21 = capabilities10;
                                    let len21 = vec21.len();
                                    let layout21 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec21.len() * 40,
                                        4,
                                    );
                                    let result21 = if layout21.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout21).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout21);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec21.into_iter().enumerate() {
                                        let base = result21.add(i * 40);
                                        {
                                            let Capability { issuer: issuer13, params: params13 } = e;
                                            let Address { node: node14, process: process14 } = issuer13;
                                            let vec15 = node14;
                                            let ptr15 = vec15.as_ptr().cast::<u8>();
                                            let len15 = vec15.len();
                                            *base.add(4).cast::<usize>() = len15;
                                            *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                                            let ProcessId {
                                                process_name: process_name16,
                                                package_name: package_name16,
                                                publisher_node: publisher_node16,
                                            } = process14;
                                            let vec17 = process_name16;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base.add(12).cast::<usize>() = len17;
                                            *base.add(8).cast::<*mut u8>() = ptr17.cast_mut();
                                            let vec18 = package_name16;
                                            let ptr18 = vec18.as_ptr().cast::<u8>();
                                            let len18 = vec18.len();
                                            *base.add(20).cast::<usize>() = len18;
                                            *base.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                            let vec19 = publisher_node16;
                                            let ptr19 = vec19.as_ptr().cast::<u8>();
                                            let len19 = vec19.len();
                                            *base.add(28).cast::<usize>() = len19;
                                            *base.add(24).cast::<*mut u8>() = ptr19.cast_mut();
                                            let vec20 = params13;
                                            let ptr20 = vec20.as_ptr().cast::<u8>();
                                            let len20 = vec20.len();
                                            *base.add(36).cast::<usize>() = len20;
                                            *base.add(32).cast::<*mut u8>() = ptr20.cast_mut();
                                        }
                                    }
                                    *base.add(80).cast::<usize>() = len21;
                                    *base.add(76).cast::<*mut u8>() = result21;
                                    match t3_2 {
                                        Some(e) => {
                                            *base.add(88).cast::<u8>() = (1i32) as u8;
                                            let LazyLoadBlob { mime: mime22, bytes: bytes22 } = e;
                                            match mime22 {
                                                Some(e) => {
                                                    *base.add(92).cast::<u8>() = (1i32) as u8;
                                                    let vec23 = e;
                                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                                    let len23 = vec23.len();
                                                    *base.add(100).cast::<usize>() = len23;
                                                    *base.add(96).cast::<*mut u8>() = ptr23.cast_mut();
                                                }
                                                None => {
                                                    *base.add(92).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            let vec24 = bytes22;
                                            let ptr24 = vec24.as_ptr().cast::<u8>();
                                            let len24 = vec24.len();
                                            *base.add(108).cast::<usize>() = len24;
                                            *base.add(104).cast::<*mut u8>() = ptr24.cast_mut();
                                        }
                                        None => {
                                            *base.add(88).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    cleanup_list.extend_from_slice(&[(result21, layout21)]);
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result25, layout25)]);
                            (2i32, result25, len25)
                        }
                    };
                    let vec35 = request_capabilities;
                    let len35 = vec35.len();
                    let layout35 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec35.len() * 40,
                        4,
                    );
                    let result35 = if layout35.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout35).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout35);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec35.into_iter().enumerate() {
                        let base = result35.add(i * 40);
                        {
                            let Capability { issuer: issuer27, params: params27 } = e;
                            let Address { node: node28, process: process28 } = issuer27;
                            let vec29 = node28;
                            let ptr29 = vec29.as_ptr().cast::<u8>();
                            let len29 = vec29.len();
                            *base.add(4).cast::<usize>() = len29;
                            *base.add(0).cast::<*mut u8>() = ptr29.cast_mut();
                            let ProcessId {
                                process_name: process_name30,
                                package_name: package_name30,
                                publisher_node: publisher_node30,
                            } = process28;
                            let vec31 = process_name30;
                            let ptr31 = vec31.as_ptr().cast::<u8>();
                            let len31 = vec31.len();
                            *base.add(12).cast::<usize>() = len31;
                            *base.add(8).cast::<*mut u8>() = ptr31.cast_mut();
                            let vec32 = package_name30;
                            let ptr32 = vec32.as_ptr().cast::<u8>();
                            let len32 = vec32.len();
                            *base.add(20).cast::<usize>() = len32;
                            *base.add(16).cast::<*mut u8>() = ptr32.cast_mut();
                            let vec33 = publisher_node30;
                            let ptr33 = vec33.as_ptr().cast::<u8>();
                            let len33 = vec33.len();
                            *base.add(28).cast::<usize>() = len33;
                            *base.add(24).cast::<*mut u8>() = ptr33.cast_mut();
                            let vec34 = params27;
                            let ptr34 = vec34.as_ptr().cast::<u8>();
                            let len34 = vec34.len();
                            *base.add(36).cast::<usize>() = len34;
                            *base.add(32).cast::<*mut u8>() = ptr34.cast_mut();
                        }
                    }
                    let vec42 = grant_capabilities;
                    let len42 = vec42.len();
                    let layout42 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec42.len() * 32,
                        4,
                    );
                    let result42 = if layout42.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout42).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout42);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec42.into_iter().enumerate() {
                        let base = result42.add(i * 32);
                        {
                            let (t36_0, t36_1) = e;
                            let ProcessId {
                                process_name: process_name37,
                                package_name: package_name37,
                                publisher_node: publisher_node37,
                            } = t36_0;
                            let vec38 = process_name37;
                            let ptr38 = vec38.as_ptr().cast::<u8>();
                            let len38 = vec38.len();
                            *base.add(4).cast::<usize>() = len38;
                            *base.add(0).cast::<*mut u8>() = ptr38.cast_mut();
                            let vec39 = package_name37;
                            let ptr39 = vec39.as_ptr().cast::<u8>();
                            let len39 = vec39.len();
                            *base.add(12).cast::<usize>() = len39;
                            *base.add(8).cast::<*mut u8>() = ptr39.cast_mut();
                            let vec40 = publisher_node37;
                            let ptr40 = vec40.as_ptr().cast::<u8>();
                            let len40 = vec40.len();
                            *base.add(20).cast::<usize>() = len40;
                            *base.add(16).cast::<*mut u8>() = ptr40.cast_mut();
                            let vec41 = t36_1;
                            let ptr41 = vec41.as_ptr().cast::<u8>();
                            let len41 = vec41.len();
                            *base.add(28).cast::<usize>() = len41;
                            *base.add(24).cast::<*mut u8>() = ptr41.cast_mut();
                        }
                    }
                    let ptr43 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                    ) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(
                        result1_0,
                        result1_1,
                        result1_2,
                        ptr2.cast_mut(),
                        len2,
                        result26_0,
                        result26_1,
                        result26_2,
                        result35,
                        len35,
                        result42,
                        len42,
                        match &public {
                            true => 1,
                            false => 0,
                        },
                        ptr43,
                    );
                    let l44 = i32::from(*ptr43.add(0).cast::<u8>());
                    if layout35.size() != 0 {
                        _rt::alloc::dealloc(result35.cast(), layout35);
                    }
                    if layout42.size() != 0 {
                        _rt::alloc::dealloc(result42.cast(), layout42);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                    match l44 {
                        0 => {
                            let e = {
                                let l45 = *ptr43.add(4).cast::<*mut u8>();
                                let l46 = *ptr43.add(8).cast::<usize>();
                                let len47 = l46;
                                let bytes47 = _rt::Vec::from_raw_parts(
                                    l45.cast(),
                                    len47,
                                    len47,
                                );
                                let l48 = *ptr43.add(12).cast::<*mut u8>();
                                let l49 = *ptr43.add(16).cast::<usize>();
                                let len50 = l49;
                                let bytes50 = _rt::Vec::from_raw_parts(
                                    l48.cast(),
                                    len50,
                                    len50,
                                );
                                let l51 = *ptr43.add(20).cast::<*mut u8>();
                                let l52 = *ptr43.add(24).cast::<usize>();
                                let len53 = l52;
                                let bytes53 = _rt::Vec::from_raw_parts(
                                    l51.cast(),
                                    len53,
                                    len53,
                                );
                                ProcessId {
                                    process_name: _rt::string_lift(bytes47),
                                    package_name: _rt::string_lift(bytes50),
                                    publisher_node: _rt::string_lift(bytes53),
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l54 = i32::from(*ptr43.add(4).cast::<u8>());
                                SpawnError::_lift(l54 as u8)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ˗ˏˋ ♡ ˎˊ˗
            /// Capabilities Management
            /// ˗ˏˋ ♡ ˎˊ˗
            /// Saves the capabilities to persisted process state.
            pub fn save_capabilities(caps: &[Capability]) {
                unsafe {
                    let vec8 = caps;
                    let len8 = vec8.len();
                    let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec8.len() * 40,
                        4,
                    );
                    let result8 = if layout8.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout8);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec8.into_iter().enumerate() {
                        let base = result8.add(i * 40);
                        {
                            let Capability { issuer: issuer0, params: params0 } = e;
                            let Address { node: node1, process: process1 } = issuer0;
                            let vec2 = node1;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                            let ProcessId {
                                process_name: process_name3,
                                package_name: package_name3,
                                publisher_node: publisher_node3,
                            } = process1;
                            let vec4 = process_name3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(12).cast::<usize>() = len4;
                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = package_name3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base.add(20).cast::<usize>() = len5;
                            *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = publisher_node3;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(28).cast::<usize>() = len6;
                            *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                            let vec7 = params0;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base.add(36).cast::<usize>() = len7;
                            *base.add(32).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result8, len8);
                    if layout8.size() != 0 {
                        _rt::alloc::dealloc(result8.cast(), layout8);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Deletes the capabilities from persisted process state.
            pub fn drop_capabilities(caps: &[Capability]) {
                unsafe {
                    let vec8 = caps;
                    let len8 = vec8.len();
                    let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec8.len() * 40,
                        4,
                    );
                    let result8 = if layout8.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout8);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec8.into_iter().enumerate() {
                        let base = result8.add(i * 40);
                        {
                            let Capability { issuer: issuer0, params: params0 } = e;
                            let Address { node: node1, process: process1 } = issuer0;
                            let vec2 = node1;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                            let ProcessId {
                                process_name: process_name3,
                                package_name: package_name3,
                                publisher_node: publisher_node3,
                            } = process1;
                            let vec4 = process_name3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(12).cast::<usize>() = len4;
                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = package_name3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base.add(20).cast::<usize>() = len5;
                            *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = publisher_node3;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(28).cast::<usize>() = len6;
                            *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                            let vec7 = params0;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base.add(36).cast::<usize>() = len7;
                            *base.add(32).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result8, len8);
                    if layout8.size() != 0 {
                        _rt::alloc::dealloc(result8.cast(), layout8);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Gets all capabilities from persisted process state.
            pub fn our_capabilities() -> _rt::Vec<Capability> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let base18 = l1;
                    let len18 = l2;
                    let mut result18 = _rt::Vec::with_capacity(len18);
                    for i in 0..len18 {
                        let base = base18.add(i * 40);
                        let e18 = {
                            let l3 = *base.add(0).cast::<*mut u8>();
                            let l4 = *base.add(4).cast::<usize>();
                            let len5 = l4;
                            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                            let l6 = *base.add(8).cast::<*mut u8>();
                            let l7 = *base.add(12).cast::<usize>();
                            let len8 = l7;
                            let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                            let l9 = *base.add(16).cast::<*mut u8>();
                            let l10 = *base.add(20).cast::<usize>();
                            let len11 = l10;
                            let bytes11 = _rt::Vec::from_raw_parts(
                                l9.cast(),
                                len11,
                                len11,
                            );
                            let l12 = *base.add(24).cast::<*mut u8>();
                            let l13 = *base.add(28).cast::<usize>();
                            let len14 = l13;
                            let bytes14 = _rt::Vec::from_raw_parts(
                                l12.cast(),
                                len14,
                                len14,
                            );
                            let l15 = *base.add(32).cast::<*mut u8>();
                            let l16 = *base.add(36).cast::<usize>();
                            let len17 = l16;
                            let bytes17 = _rt::Vec::from_raw_parts(
                                l15.cast(),
                                len17,
                                len17,
                            );
                            Capability {
                                issuer: Address {
                                    node: _rt::string_lift(bytes5),
                                    process: ProcessId {
                                        process_name: _rt::string_lift(bytes8),
                                        package_name: _rt::string_lift(bytes11),
                                        publisher_node: _rt::string_lift(bytes14),
                                    },
                                },
                                params: _rt::string_lift(bytes17),
                            }
                        };
                        result18.push(e18);
                    }
                    _rt::cabi_dealloc(base18, len18 * 40, 4);
                    result18
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// ˗ˏˋ ♡ ˎˊ˗
            /// Message I/O
            /// ˗ˏˋ ♡ ˎˊ˗
            /// Ingest next message when it arrives along with its source.
            /// Almost all long-running processes will call this in a loop.
            pub fn receive() -> Result<
                (Address, Message),
                (SendError, Option<Context>),
            > {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 152]);
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 152],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => {
                            let e = {
                                let l2 = *ptr0.add(8).cast::<*mut u8>();
                                let l3 = *ptr0.add(12).cast::<usize>();
                                let len4 = l3;
                                let bytes4 = _rt::Vec::from_raw_parts(
                                    l2.cast(),
                                    len4,
                                    len4,
                                );
                                let l5 = *ptr0.add(16).cast::<*mut u8>();
                                let l6 = *ptr0.add(20).cast::<usize>();
                                let len7 = l6;
                                let bytes7 = _rt::Vec::from_raw_parts(
                                    l5.cast(),
                                    len7,
                                    len7,
                                );
                                let l8 = *ptr0.add(24).cast::<*mut u8>();
                                let l9 = *ptr0.add(28).cast::<usize>();
                                let len10 = l9;
                                let bytes10 = _rt::Vec::from_raw_parts(
                                    l8.cast(),
                                    len10,
                                    len10,
                                );
                                let l11 = *ptr0.add(32).cast::<*mut u8>();
                                let l12 = *ptr0.add(36).cast::<usize>();
                                let len13 = l12;
                                let bytes13 = _rt::Vec::from_raw_parts(
                                    l11.cast(),
                                    len13,
                                    len13,
                                );
                                let l14 = i32::from(*ptr0.add(40).cast::<u8>());
                                let v73 = match l14 {
                                    0 => {
                                        let e73 = {
                                            let l15 = i32::from(*ptr0.add(48).cast::<u8>());
                                            let l16 = i32::from(*ptr0.add(56).cast::<u8>());
                                            let l18 = *ptr0.add(72).cast::<*mut u8>();
                                            let l19 = *ptr0.add(76).cast::<usize>();
                                            let len20 = l19;
                                            let l21 = i32::from(*ptr0.add(80).cast::<u8>());
                                            let l25 = *ptr0.add(92).cast::<*mut u8>();
                                            let l26 = *ptr0.add(96).cast::<usize>();
                                            let base42 = l25;
                                            let len42 = l26;
                                            let mut result42 = _rt::Vec::with_capacity(len42);
                                            for i in 0..len42 {
                                                let base = base42.add(i * 40);
                                                let e42 = {
                                                    let l27 = *base.add(0).cast::<*mut u8>();
                                                    let l28 = *base.add(4).cast::<usize>();
                                                    let len29 = l28;
                                                    let bytes29 = _rt::Vec::from_raw_parts(
                                                        l27.cast(),
                                                        len29,
                                                        len29,
                                                    );
                                                    let l30 = *base.add(8).cast::<*mut u8>();
                                                    let l31 = *base.add(12).cast::<usize>();
                                                    let len32 = l31;
                                                    let bytes32 = _rt::Vec::from_raw_parts(
                                                        l30.cast(),
                                                        len32,
                                                        len32,
                                                    );
                                                    let l33 = *base.add(16).cast::<*mut u8>();
                                                    let l34 = *base.add(20).cast::<usize>();
                                                    let len35 = l34;
                                                    let bytes35 = _rt::Vec::from_raw_parts(
                                                        l33.cast(),
                                                        len35,
                                                        len35,
                                                    );
                                                    let l36 = *base.add(24).cast::<*mut u8>();
                                                    let l37 = *base.add(28).cast::<usize>();
                                                    let len38 = l37;
                                                    let bytes38 = _rt::Vec::from_raw_parts(
                                                        l36.cast(),
                                                        len38,
                                                        len38,
                                                    );
                                                    let l39 = *base.add(32).cast::<*mut u8>();
                                                    let l40 = *base.add(36).cast::<usize>();
                                                    let len41 = l40;
                                                    let bytes41 = _rt::Vec::from_raw_parts(
                                                        l39.cast(),
                                                        len41,
                                                        len41,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes29),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes32),
                                                                package_name: _rt::string_lift(bytes35),
                                                                publisher_node: _rt::string_lift(bytes38),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes41),
                                                    }
                                                };
                                                result42.push(e42);
                                            }
                                            _rt::cabi_dealloc(base42, len42 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l15 as u8),
                                                expects_response: match l16 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l17 = *ptr0.add(64).cast::<i64>();
                                                            l17 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l18.cast(), len20, len20),
                                                metadata: match l21 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l22 = *ptr0.add(84).cast::<*mut u8>();
                                                            let l23 = *ptr0.add(88).cast::<usize>();
                                                            let len24 = l23;
                                                            let bytes24 = _rt::Vec::from_raw_parts(
                                                                l22.cast(),
                                                                len24,
                                                                len24,
                                                            );
                                                            _rt::string_lift(bytes24)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result42,
                                            }
                                        };
                                        Message::Request(e73)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e73 = {
                                            let l43 = i32::from(*ptr0.add(48).cast::<u8>());
                                            let l44 = *ptr0.add(52).cast::<*mut u8>();
                                            let l45 = *ptr0.add(56).cast::<usize>();
                                            let len46 = l45;
                                            let l47 = i32::from(*ptr0.add(60).cast::<u8>());
                                            let l51 = *ptr0.add(72).cast::<*mut u8>();
                                            let l52 = *ptr0.add(76).cast::<usize>();
                                            let base68 = l51;
                                            let len68 = l52;
                                            let mut result68 = _rt::Vec::with_capacity(len68);
                                            for i in 0..len68 {
                                                let base = base68.add(i * 40);
                                                let e68 = {
                                                    let l53 = *base.add(0).cast::<*mut u8>();
                                                    let l54 = *base.add(4).cast::<usize>();
                                                    let len55 = l54;
                                                    let bytes55 = _rt::Vec::from_raw_parts(
                                                        l53.cast(),
                                                        len55,
                                                        len55,
                                                    );
                                                    let l56 = *base.add(8).cast::<*mut u8>();
                                                    let l57 = *base.add(12).cast::<usize>();
                                                    let len58 = l57;
                                                    let bytes58 = _rt::Vec::from_raw_parts(
                                                        l56.cast(),
                                                        len58,
                                                        len58,
                                                    );
                                                    let l59 = *base.add(16).cast::<*mut u8>();
                                                    let l60 = *base.add(20).cast::<usize>();
                                                    let len61 = l60;
                                                    let bytes61 = _rt::Vec::from_raw_parts(
                                                        l59.cast(),
                                                        len61,
                                                        len61,
                                                    );
                                                    let l62 = *base.add(24).cast::<*mut u8>();
                                                    let l63 = *base.add(28).cast::<usize>();
                                                    let len64 = l63;
                                                    let bytes64 = _rt::Vec::from_raw_parts(
                                                        l62.cast(),
                                                        len64,
                                                        len64,
                                                    );
                                                    let l65 = *base.add(32).cast::<*mut u8>();
                                                    let l66 = *base.add(36).cast::<usize>();
                                                    let len67 = l66;
                                                    let bytes67 = _rt::Vec::from_raw_parts(
                                                        l65.cast(),
                                                        len67,
                                                        len67,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes55),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes58),
                                                                package_name: _rt::string_lift(bytes61),
                                                                publisher_node: _rt::string_lift(bytes64),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes67),
                                                    }
                                                };
                                                result68.push(e68);
                                            }
                                            _rt::cabi_dealloc(base68, len68 * 40, 4);
                                            let l69 = i32::from(*ptr0.add(80).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l43 as u8),
                                                    body: _rt::Vec::from_raw_parts(l44.cast(), len46, len46),
                                                    metadata: match l47 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l48 = *ptr0.add(64).cast::<*mut u8>();
                                                                let l49 = *ptr0.add(68).cast::<usize>();
                                                                let len50 = l49;
                                                                let bytes50 = _rt::Vec::from_raw_parts(
                                                                    l48.cast(),
                                                                    len50,
                                                                    len50,
                                                                );
                                                                _rt::string_lift(bytes50)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result68,
                                                },
                                                match l69 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l70 = *ptr0.add(84).cast::<*mut u8>();
                                                            let l71 = *ptr0.add(88).cast::<usize>();
                                                            let len72 = l71;
                                                            _rt::Vec::from_raw_parts(l70.cast(), len72, len72)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e73)
                                    }
                                };
                                (
                                    Address {
                                        node: _rt::string_lift(bytes4),
                                        process: ProcessId {
                                            process_name: _rt::string_lift(bytes7),
                                            package_name: _rt::string_lift(bytes10),
                                            publisher_node: _rt::string_lift(bytes13),
                                        },
                                    },
                                    v73,
                                )
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l74 = i32::from(*ptr0.add(8).cast::<u8>());
                                let l75 = *ptr0.add(12).cast::<*mut u8>();
                                let l76 = *ptr0.add(16).cast::<usize>();
                                let len77 = l76;
                                let bytes77 = _rt::Vec::from_raw_parts(
                                    l75.cast(),
                                    len77,
                                    len77,
                                );
                                let l78 = *ptr0.add(20).cast::<*mut u8>();
                                let l79 = *ptr0.add(24).cast::<usize>();
                                let len80 = l79;
                                let bytes80 = _rt::Vec::from_raw_parts(
                                    l78.cast(),
                                    len80,
                                    len80,
                                );
                                let l81 = *ptr0.add(28).cast::<*mut u8>();
                                let l82 = *ptr0.add(32).cast::<usize>();
                                let len83 = l82;
                                let bytes83 = _rt::Vec::from_raw_parts(
                                    l81.cast(),
                                    len83,
                                    len83,
                                );
                                let l84 = *ptr0.add(36).cast::<*mut u8>();
                                let l85 = *ptr0.add(40).cast::<usize>();
                                let len86 = l85;
                                let bytes86 = _rt::Vec::from_raw_parts(
                                    l84.cast(),
                                    len86,
                                    len86,
                                );
                                let l87 = i32::from(*ptr0.add(48).cast::<u8>());
                                let v146 = match l87 {
                                    0 => {
                                        let e146 = {
                                            let l88 = i32::from(*ptr0.add(56).cast::<u8>());
                                            let l89 = i32::from(*ptr0.add(64).cast::<u8>());
                                            let l91 = *ptr0.add(80).cast::<*mut u8>();
                                            let l92 = *ptr0.add(84).cast::<usize>();
                                            let len93 = l92;
                                            let l94 = i32::from(*ptr0.add(88).cast::<u8>());
                                            let l98 = *ptr0.add(100).cast::<*mut u8>();
                                            let l99 = *ptr0.add(104).cast::<usize>();
                                            let base115 = l98;
                                            let len115 = l99;
                                            let mut result115 = _rt::Vec::with_capacity(len115);
                                            for i in 0..len115 {
                                                let base = base115.add(i * 40);
                                                let e115 = {
                                                    let l100 = *base.add(0).cast::<*mut u8>();
                                                    let l101 = *base.add(4).cast::<usize>();
                                                    let len102 = l101;
                                                    let bytes102 = _rt::Vec::from_raw_parts(
                                                        l100.cast(),
                                                        len102,
                                                        len102,
                                                    );
                                                    let l103 = *base.add(8).cast::<*mut u8>();
                                                    let l104 = *base.add(12).cast::<usize>();
                                                    let len105 = l104;
                                                    let bytes105 = _rt::Vec::from_raw_parts(
                                                        l103.cast(),
                                                        len105,
                                                        len105,
                                                    );
                                                    let l106 = *base.add(16).cast::<*mut u8>();
                                                    let l107 = *base.add(20).cast::<usize>();
                                                    let len108 = l107;
                                                    let bytes108 = _rt::Vec::from_raw_parts(
                                                        l106.cast(),
                                                        len108,
                                                        len108,
                                                    );
                                                    let l109 = *base.add(24).cast::<*mut u8>();
                                                    let l110 = *base.add(28).cast::<usize>();
                                                    let len111 = l110;
                                                    let bytes111 = _rt::Vec::from_raw_parts(
                                                        l109.cast(),
                                                        len111,
                                                        len111,
                                                    );
                                                    let l112 = *base.add(32).cast::<*mut u8>();
                                                    let l113 = *base.add(36).cast::<usize>();
                                                    let len114 = l113;
                                                    let bytes114 = _rt::Vec::from_raw_parts(
                                                        l112.cast(),
                                                        len114,
                                                        len114,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes102),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes105),
                                                                package_name: _rt::string_lift(bytes108),
                                                                publisher_node: _rt::string_lift(bytes111),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes114),
                                                    }
                                                };
                                                result115.push(e115);
                                            }
                                            _rt::cabi_dealloc(base115, len115 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l88 as u8),
                                                expects_response: match l89 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l90 = *ptr0.add(72).cast::<i64>();
                                                            l90 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l91.cast(), len93, len93),
                                                metadata: match l94 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l95 = *ptr0.add(92).cast::<*mut u8>();
                                                            let l96 = *ptr0.add(96).cast::<usize>();
                                                            let len97 = l96;
                                                            let bytes97 = _rt::Vec::from_raw_parts(
                                                                l95.cast(),
                                                                len97,
                                                                len97,
                                                            );
                                                            _rt::string_lift(bytes97)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result115,
                                            }
                                        };
                                        Message::Request(e146)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e146 = {
                                            let l116 = i32::from(*ptr0.add(56).cast::<u8>());
                                            let l117 = *ptr0.add(60).cast::<*mut u8>();
                                            let l118 = *ptr0.add(64).cast::<usize>();
                                            let len119 = l118;
                                            let l120 = i32::from(*ptr0.add(68).cast::<u8>());
                                            let l124 = *ptr0.add(80).cast::<*mut u8>();
                                            let l125 = *ptr0.add(84).cast::<usize>();
                                            let base141 = l124;
                                            let len141 = l125;
                                            let mut result141 = _rt::Vec::with_capacity(len141);
                                            for i in 0..len141 {
                                                let base = base141.add(i * 40);
                                                let e141 = {
                                                    let l126 = *base.add(0).cast::<*mut u8>();
                                                    let l127 = *base.add(4).cast::<usize>();
                                                    let len128 = l127;
                                                    let bytes128 = _rt::Vec::from_raw_parts(
                                                        l126.cast(),
                                                        len128,
                                                        len128,
                                                    );
                                                    let l129 = *base.add(8).cast::<*mut u8>();
                                                    let l130 = *base.add(12).cast::<usize>();
                                                    let len131 = l130;
                                                    let bytes131 = _rt::Vec::from_raw_parts(
                                                        l129.cast(),
                                                        len131,
                                                        len131,
                                                    );
                                                    let l132 = *base.add(16).cast::<*mut u8>();
                                                    let l133 = *base.add(20).cast::<usize>();
                                                    let len134 = l133;
                                                    let bytes134 = _rt::Vec::from_raw_parts(
                                                        l132.cast(),
                                                        len134,
                                                        len134,
                                                    );
                                                    let l135 = *base.add(24).cast::<*mut u8>();
                                                    let l136 = *base.add(28).cast::<usize>();
                                                    let len137 = l136;
                                                    let bytes137 = _rt::Vec::from_raw_parts(
                                                        l135.cast(),
                                                        len137,
                                                        len137,
                                                    );
                                                    let l138 = *base.add(32).cast::<*mut u8>();
                                                    let l139 = *base.add(36).cast::<usize>();
                                                    let len140 = l139;
                                                    let bytes140 = _rt::Vec::from_raw_parts(
                                                        l138.cast(),
                                                        len140,
                                                        len140,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes128),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes131),
                                                                package_name: _rt::string_lift(bytes134),
                                                                publisher_node: _rt::string_lift(bytes137),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes140),
                                                    }
                                                };
                                                result141.push(e141);
                                            }
                                            _rt::cabi_dealloc(base141, len141 * 40, 4);
                                            let l142 = i32::from(*ptr0.add(88).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l116 as u8),
                                                    body: _rt::Vec::from_raw_parts(l117.cast(), len119, len119),
                                                    metadata: match l120 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l121 = *ptr0.add(72).cast::<*mut u8>();
                                                                let l122 = *ptr0.add(76).cast::<usize>();
                                                                let len123 = l122;
                                                                let bytes123 = _rt::Vec::from_raw_parts(
                                                                    l121.cast(),
                                                                    len123,
                                                                    len123,
                                                                );
                                                                _rt::string_lift(bytes123)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result141,
                                                },
                                                match l142 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l143 = *ptr0.add(92).cast::<*mut u8>();
                                                            let l144 = *ptr0.add(96).cast::<usize>();
                                                            let len145 = l144;
                                                            _rt::Vec::from_raw_parts(l143.cast(), len145, len145)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e146)
                                    }
                                };
                                let l147 = i32::from(*ptr0.add(112).cast::<u8>());
                                let l155 = i32::from(*ptr0.add(136).cast::<u8>());
                                (
                                    SendError {
                                        kind: SendErrorKind::_lift(l74 as u8),
                                        target: Address {
                                            node: _rt::string_lift(bytes77),
                                            process: ProcessId {
                                                process_name: _rt::string_lift(bytes80),
                                                package_name: _rt::string_lift(bytes83),
                                                publisher_node: _rt::string_lift(bytes86),
                                            },
                                        },
                                        message: v146,
                                        lazy_load_blob: match l147 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l148 = i32::from(*ptr0.add(116).cast::<u8>());
                                                    let l152 = *ptr0.add(128).cast::<*mut u8>();
                                                    let l153 = *ptr0.add(132).cast::<usize>();
                                                    let len154 = l153;
                                                    LazyLoadBlob {
                                                        mime: match l148 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l149 = *ptr0.add(120).cast::<*mut u8>();
                                                                    let l150 = *ptr0.add(124).cast::<usize>();
                                                                    let len151 = l150;
                                                                    let bytes151 = _rt::Vec::from_raw_parts(
                                                                        l149.cast(),
                                                                        len151,
                                                                        len151,
                                                                    );
                                                                    _rt::string_lift(bytes151)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bytes: _rt::Vec::from_raw_parts(l152.cast(), len154, len154),
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    },
                                    match l155 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l156 = *ptr0.add(140).cast::<*mut u8>();
                                                let l157 = *ptr0.add(144).cast::<usize>();
                                                let len158 = l157;
                                                _rt::Vec::from_raw_parts(l156.cast(), len158, len158)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                )
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns whether or not the current message has a blob.
            pub fn has_blob() -> bool {
                unsafe {
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import();
                    _rt::bool_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the blob of the current message, if any.
            pub fn get_blob() -> Option<LazyLoadBlob> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => None,
                        1 => {
                            let e = {
                                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                                let l6 = *ptr0.add(16).cast::<*mut u8>();
                                let l7 = *ptr0.add(20).cast::<usize>();
                                let len8 = l7;
                                LazyLoadBlob {
                                    mime: match l2 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l3 = *ptr0.add(8).cast::<*mut u8>();
                                                let l4 = *ptr0.add(12).cast::<usize>();
                                                let len5 = l4;
                                                let bytes5 = _rt::Vec::from_raw_parts(
                                                    l3.cast(),
                                                    len5,
                                                    len5,
                                                );
                                                _rt::string_lift(bytes5)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    bytes: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the last blob this process received.
            pub fn last_blob() -> Option<LazyLoadBlob> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => None,
                        1 => {
                            let e = {
                                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                                let l6 = *ptr0.add(16).cast::<*mut u8>();
                                let l7 = *ptr0.add(20).cast::<usize>();
                                let len8 = l7;
                                LazyLoadBlob {
                                    mime: match l2 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l3 = *ptr0.add(8).cast::<*mut u8>();
                                                let l4 = *ptr0.add(12).cast::<usize>();
                                                let len5 = l4;
                                                let bytes5 = _rt::Vec::from_raw_parts(
                                                    l3.cast(),
                                                    len5,
                                                    len5,
                                                );
                                                _rt::string_lift(bytes5)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    bytes: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send request to target.
            pub fn send_request(
                target: &Address,
                request: &Request,
                context: Option<&Context>,
                lazy_load_blob: Option<&LazyLoadBlob>,
            ) {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 128]);
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 128],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    let Address { node: node1, process: process1 } = target;
                    let vec2 = node1;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    *ptr0.add(4).cast::<usize>() = len2;
                    *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    let ProcessId {
                        process_name: process_name3,
                        package_name: package_name3,
                        publisher_node: publisher_node3,
                    } = process1;
                    let vec4 = process_name3;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(12).cast::<usize>() = len4;
                    *ptr0.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = package_name3;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(20).cast::<usize>() = len5;
                    *ptr0.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                    let vec6 = publisher_node3;
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    *ptr0.add(28).cast::<usize>() = len6;
                    *ptr0.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                    let Request {
                        inherit: inherit7,
                        expects_response: expects_response7,
                        body: body7,
                        metadata: metadata7,
                        capabilities: capabilities7,
                    } = request;
                    *ptr0.add(32).cast::<u8>() = (match inherit7 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    match expects_response7 {
                        Some(e) => {
                            *ptr0.add(40).cast::<u8>() = (1i32) as u8;
                            *ptr0.add(48).cast::<i64>() = _rt::as_i64(e);
                        }
                        None => {
                            *ptr0.add(40).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec8 = body7;
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    *ptr0.add(60).cast::<usize>() = len8;
                    *ptr0.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                    match metadata7 {
                        Some(e) => {
                            *ptr0.add(64).cast::<u8>() = (1i32) as u8;
                            let vec9 = e;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *ptr0.add(72).cast::<usize>() = len9;
                            *ptr0.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                        }
                        None => {
                            *ptr0.add(64).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec18 = capabilities7;
                    let len18 = vec18.len();
                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec18.len() * 40,
                        4,
                    );
                    let result18 = if layout18.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout18);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec18.into_iter().enumerate() {
                        let base = result18.add(i * 40);
                        {
                            let Capability { issuer: issuer10, params: params10 } = e;
                            let Address { node: node11, process: process11 } = issuer10;
                            let vec12 = node11;
                            let ptr12 = vec12.as_ptr().cast::<u8>();
                            let len12 = vec12.len();
                            *base.add(4).cast::<usize>() = len12;
                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                            let ProcessId {
                                process_name: process_name13,
                                package_name: package_name13,
                                publisher_node: publisher_node13,
                            } = process11;
                            let vec14 = process_name13;
                            let ptr14 = vec14.as_ptr().cast::<u8>();
                            let len14 = vec14.len();
                            *base.add(12).cast::<usize>() = len14;
                            *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                            let vec15 = package_name13;
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            *base.add(20).cast::<usize>() = len15;
                            *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                            let vec16 = publisher_node13;
                            let ptr16 = vec16.as_ptr().cast::<u8>();
                            let len16 = vec16.len();
                            *base.add(28).cast::<usize>() = len16;
                            *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                            let vec17 = params10;
                            let ptr17 = vec17.as_ptr().cast::<u8>();
                            let len17 = vec17.len();
                            *base.add(36).cast::<usize>() = len17;
                            *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                        }
                    }
                    *ptr0.add(80).cast::<usize>() = len18;
                    *ptr0.add(76).cast::<*mut u8>() = result18;
                    match context {
                        Some(e) => {
                            *ptr0.add(88).cast::<u8>() = (1i32) as u8;
                            let vec19 = e;
                            let ptr19 = vec19.as_ptr().cast::<u8>();
                            let len19 = vec19.len();
                            *ptr0.add(96).cast::<usize>() = len19;
                            *ptr0.add(92).cast::<*mut u8>() = ptr19.cast_mut();
                        }
                        None => {
                            *ptr0.add(88).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match lazy_load_blob {
                        Some(e) => {
                            *ptr0.add(100).cast::<u8>() = (1i32) as u8;
                            let LazyLoadBlob { mime: mime20, bytes: bytes20 } = e;
                            match mime20 {
                                Some(e) => {
                                    *ptr0.add(104).cast::<u8>() = (1i32) as u8;
                                    let vec21 = e;
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    *ptr0.add(112).cast::<usize>() = len21;
                                    *ptr0.add(108).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                None => {
                                    *ptr0.add(104).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec22 = bytes20;
                            let ptr22 = vec22.as_ptr().cast::<u8>();
                            let len22 = vec22.len();
                            *ptr0.add(120).cast::<usize>() = len22;
                            *ptr0.add(116).cast::<*mut u8>() = ptr22.cast_mut();
                        }
                        None => {
                            *ptr0.add(100).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    if layout18.size() != 0 {
                        _rt::alloc::dealloc(result18.cast(), layout18);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send requests to targets.
            pub fn send_requests(
                requests: &[(Address, Request, Option<Context>, Option<LazyLoadBlob>)],
            ) {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    let vec23 = requests;
                    let len23 = vec23.len();
                    let layout23 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec23.len() * 128,
                        8,
                    );
                    let result23 = if layout23.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout23).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout23);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec23.into_iter().enumerate() {
                        let base = result23.add(i * 128);
                        {
                            let (t0_0, t0_1, t0_2, t0_3) = e;
                            let Address { node: node1, process: process1 } = t0_0;
                            let vec2 = node1;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                            let ProcessId {
                                process_name: process_name3,
                                package_name: package_name3,
                                publisher_node: publisher_node3,
                            } = process1;
                            let vec4 = process_name3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(12).cast::<usize>() = len4;
                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = package_name3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base.add(20).cast::<usize>() = len5;
                            *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = publisher_node3;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(28).cast::<usize>() = len6;
                            *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                            let Request {
                                inherit: inherit7,
                                expects_response: expects_response7,
                                body: body7,
                                metadata: metadata7,
                                capabilities: capabilities7,
                            } = t0_1;
                            *base.add(32).cast::<u8>() = (match inherit7 {
                                true => 1,
                                false => 0,
                            }) as u8;
                            match expects_response7 {
                                Some(e) => {
                                    *base.add(40).cast::<u8>() = (1i32) as u8;
                                    *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *base.add(40).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec8 = body7;
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            *base.add(60).cast::<usize>() = len8;
                            *base.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                            match metadata7 {
                                Some(e) => {
                                    *base.add(64).cast::<u8>() = (1i32) as u8;
                                    let vec9 = e;
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    *base.add(72).cast::<usize>() = len9;
                                    *base.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                None => {
                                    *base.add(64).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec18 = capabilities7;
                            let len18 = vec18.len();
                            let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec18.len() * 40,
                                4,
                            );
                            let result18 = if layout18.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout18);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec18.into_iter().enumerate() {
                                let base = result18.add(i * 40);
                                {
                                    let Capability { issuer: issuer10, params: params10 } = e;
                                    let Address { node: node11, process: process11 } = issuer10;
                                    let vec12 = node11;
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    *base.add(4).cast::<usize>() = len12;
                                    *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                                    let ProcessId {
                                        process_name: process_name13,
                                        package_name: package_name13,
                                        publisher_node: publisher_node13,
                                    } = process11;
                                    let vec14 = process_name13;
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    *base.add(12).cast::<usize>() = len14;
                                    *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                                    let vec15 = package_name13;
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    *base.add(20).cast::<usize>() = len15;
                                    *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                    let vec16 = publisher_node13;
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    *base.add(28).cast::<usize>() = len16;
                                    *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                                    let vec17 = params10;
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    *base.add(36).cast::<usize>() = len17;
                                    *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                            }
                            *base.add(80).cast::<usize>() = len18;
                            *base.add(76).cast::<*mut u8>() = result18;
                            match t0_2 {
                                Some(e) => {
                                    *base.add(88).cast::<u8>() = (1i32) as u8;
                                    let vec19 = e;
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    *base.add(96).cast::<usize>() = len19;
                                    *base.add(92).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                None => {
                                    *base.add(88).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match t0_3 {
                                Some(e) => {
                                    *base.add(100).cast::<u8>() = (1i32) as u8;
                                    let LazyLoadBlob { mime: mime20, bytes: bytes20 } = e;
                                    match mime20 {
                                        Some(e) => {
                                            *base.add(104).cast::<u8>() = (1i32) as u8;
                                            let vec21 = e;
                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                            let len21 = vec21.len();
                                            *base.add(112).cast::<usize>() = len21;
                                            *base.add(108).cast::<*mut u8>() = ptr21.cast_mut();
                                        }
                                        None => {
                                            *base.add(104).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec22 = bytes20;
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    *base.add(120).cast::<usize>() = len22;
                                    *base.add(116).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                None => {
                                    *base.add(100).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            cleanup_list.extend_from_slice(&[(result18, layout18)]);
                        }
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result23, len23);
                    if layout23.size() != 0 {
                        _rt::alloc::dealloc(result23.cast(), layout23);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send response to the request currently being handled.
            pub fn send_response(
                response: &Response,
                lazy_load_blob: Option<&LazyLoadBlob>,
            ) {
                unsafe {
                    let Response {
                        inherit: inherit0,
                        body: body0,
                        metadata: metadata0,
                        capabilities: capabilities0,
                    } = response;
                    let vec1 = body0;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let (result3_0, result3_1, result3_2) = match metadata0 {
                        Some(e) => {
                            let vec2 = e;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            (1i32, ptr2.cast_mut(), len2)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    let vec12 = capabilities0;
                    let len12 = vec12.len();
                    let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec12.len() * 40,
                        4,
                    );
                    let result12 = if layout12.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout12);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec12.into_iter().enumerate() {
                        let base = result12.add(i * 40);
                        {
                            let Capability { issuer: issuer4, params: params4 } = e;
                            let Address { node: node5, process: process5 } = issuer4;
                            let vec6 = node5;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(4).cast::<usize>() = len6;
                            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                            let ProcessId {
                                process_name: process_name7,
                                package_name: package_name7,
                                publisher_node: publisher_node7,
                            } = process5;
                            let vec8 = process_name7;
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            *base.add(12).cast::<usize>() = len8;
                            *base.add(8).cast::<*mut u8>() = ptr8.cast_mut();
                            let vec9 = package_name7;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *base.add(20).cast::<usize>() = len9;
                            *base.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                            let vec10 = publisher_node7;
                            let ptr10 = vec10.as_ptr().cast::<u8>();
                            let len10 = vec10.len();
                            *base.add(28).cast::<usize>() = len10;
                            *base.add(24).cast::<*mut u8>() = ptr10.cast_mut();
                            let vec11 = params4;
                            let ptr11 = vec11.as_ptr().cast::<u8>();
                            let len11 = vec11.len();
                            *base.add(36).cast::<usize>() = len11;
                            *base.add(32).cast::<*mut u8>() = ptr11.cast_mut();
                        }
                    }
                    let (
                        result17_0,
                        result17_1,
                        result17_2,
                        result17_3,
                        result17_4,
                        result17_5,
                    ) = match lazy_load_blob {
                        Some(e) => {
                            let LazyLoadBlob { mime: mime13, bytes: bytes13 } = e;
                            let (result15_0, result15_1, result15_2) = match mime13 {
                                Some(e) => {
                                    let vec14 = e;
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    (1i32, ptr14.cast_mut(), len14)
                                }
                                None => (0i32, ::core::ptr::null_mut(), 0usize),
                            };
                            let vec16 = bytes13;
                            let ptr16 = vec16.as_ptr().cast::<u8>();
                            let len16 = vec16.len();
                            (
                                1i32,
                                result15_0,
                                result15_1,
                                result15_2,
                                ptr16.cast_mut(),
                                len16,
                            )
                        }
                        None => {
                            (
                                0i32,
                                0i32,
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                            )
                        }
                    };
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                    ) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(
                        match inherit0 {
                            true => 1,
                            false => 0,
                        },
                        ptr1.cast_mut(),
                        len1,
                        result3_0,
                        result3_1,
                        result3_2,
                        result12,
                        len12,
                        result17_0,
                        result17_1,
                        result17_2,
                        result17_3,
                        result17_4,
                        result17_5,
                    );
                    if layout12.size() != 0 {
                        _rt::alloc::dealloc(result12.cast(), layout12);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send a single request, then block (internally) until its response. The
            /// type returned is Message but will always contain Response.
            pub fn send_and_await_response(
                target: &Address,
                request: &Request,
                lazy_load_blob: Option<&LazyLoadBlob>,
            ) -> Result<(Address, Message), SendError> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 136]);
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 136],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    let Address { node: node1, process: process1 } = target;
                    let vec2 = node1;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    *ptr0.add(4).cast::<usize>() = len2;
                    *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    let ProcessId {
                        process_name: process_name3,
                        package_name: package_name3,
                        publisher_node: publisher_node3,
                    } = process1;
                    let vec4 = process_name3;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(12).cast::<usize>() = len4;
                    *ptr0.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = package_name3;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(20).cast::<usize>() = len5;
                    *ptr0.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                    let vec6 = publisher_node3;
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    *ptr0.add(28).cast::<usize>() = len6;
                    *ptr0.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                    let Request {
                        inherit: inherit7,
                        expects_response: expects_response7,
                        body: body7,
                        metadata: metadata7,
                        capabilities: capabilities7,
                    } = request;
                    *ptr0.add(32).cast::<u8>() = (match inherit7 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    match expects_response7 {
                        Some(e) => {
                            *ptr0.add(40).cast::<u8>() = (1i32) as u8;
                            *ptr0.add(48).cast::<i64>() = _rt::as_i64(e);
                        }
                        None => {
                            *ptr0.add(40).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec8 = body7;
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    *ptr0.add(60).cast::<usize>() = len8;
                    *ptr0.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                    match metadata7 {
                        Some(e) => {
                            *ptr0.add(64).cast::<u8>() = (1i32) as u8;
                            let vec9 = e;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *ptr0.add(72).cast::<usize>() = len9;
                            *ptr0.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                        }
                        None => {
                            *ptr0.add(64).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec18 = capabilities7;
                    let len18 = vec18.len();
                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec18.len() * 40,
                        4,
                    );
                    let result18 = if layout18.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout18);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec18.into_iter().enumerate() {
                        let base = result18.add(i * 40);
                        {
                            let Capability { issuer: issuer10, params: params10 } = e;
                            let Address { node: node11, process: process11 } = issuer10;
                            let vec12 = node11;
                            let ptr12 = vec12.as_ptr().cast::<u8>();
                            let len12 = vec12.len();
                            *base.add(4).cast::<usize>() = len12;
                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                            let ProcessId {
                                process_name: process_name13,
                                package_name: package_name13,
                                publisher_node: publisher_node13,
                            } = process11;
                            let vec14 = process_name13;
                            let ptr14 = vec14.as_ptr().cast::<u8>();
                            let len14 = vec14.len();
                            *base.add(12).cast::<usize>() = len14;
                            *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                            let vec15 = package_name13;
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            *base.add(20).cast::<usize>() = len15;
                            *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                            let vec16 = publisher_node13;
                            let ptr16 = vec16.as_ptr().cast::<u8>();
                            let len16 = vec16.len();
                            *base.add(28).cast::<usize>() = len16;
                            *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                            let vec17 = params10;
                            let ptr17 = vec17.as_ptr().cast::<u8>();
                            let len17 = vec17.len();
                            *base.add(36).cast::<usize>() = len17;
                            *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                        }
                    }
                    *ptr0.add(80).cast::<usize>() = len18;
                    *ptr0.add(76).cast::<*mut u8>() = result18;
                    match lazy_load_blob {
                        Some(e) => {
                            *ptr0.add(88).cast::<u8>() = (1i32) as u8;
                            let LazyLoadBlob { mime: mime19, bytes: bytes19 } = e;
                            match mime19 {
                                Some(e) => {
                                    *ptr0.add(92).cast::<u8>() = (1i32) as u8;
                                    let vec20 = e;
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    *ptr0.add(100).cast::<usize>() = len20;
                                    *ptr0.add(96).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                None => {
                                    *ptr0.add(92).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec21 = bytes19;
                            let ptr21 = vec21.as_ptr().cast::<u8>();
                            let len21 = vec21.len();
                            *ptr0.add(108).cast::<usize>() = len21;
                            *ptr0.add(104).cast::<*mut u8>() = ptr21.cast_mut();
                        }
                        None => {
                            *ptr0.add(88).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let ptr22 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0, ptr22);
                    let l23 = i32::from(*ptr22.add(0).cast::<u8>());
                    if layout18.size() != 0 {
                        _rt::alloc::dealloc(result18.cast(), layout18);
                    }
                    match l23 {
                        0 => {
                            let e = {
                                let l24 = *ptr22.add(8).cast::<*mut u8>();
                                let l25 = *ptr22.add(12).cast::<usize>();
                                let len26 = l25;
                                let bytes26 = _rt::Vec::from_raw_parts(
                                    l24.cast(),
                                    len26,
                                    len26,
                                );
                                let l27 = *ptr22.add(16).cast::<*mut u8>();
                                let l28 = *ptr22.add(20).cast::<usize>();
                                let len29 = l28;
                                let bytes29 = _rt::Vec::from_raw_parts(
                                    l27.cast(),
                                    len29,
                                    len29,
                                );
                                let l30 = *ptr22.add(24).cast::<*mut u8>();
                                let l31 = *ptr22.add(28).cast::<usize>();
                                let len32 = l31;
                                let bytes32 = _rt::Vec::from_raw_parts(
                                    l30.cast(),
                                    len32,
                                    len32,
                                );
                                let l33 = *ptr22.add(32).cast::<*mut u8>();
                                let l34 = *ptr22.add(36).cast::<usize>();
                                let len35 = l34;
                                let bytes35 = _rt::Vec::from_raw_parts(
                                    l33.cast(),
                                    len35,
                                    len35,
                                );
                                let l36 = i32::from(*ptr22.add(40).cast::<u8>());
                                let v95 = match l36 {
                                    0 => {
                                        let e95 = {
                                            let l37 = i32::from(*ptr22.add(48).cast::<u8>());
                                            let l38 = i32::from(*ptr22.add(56).cast::<u8>());
                                            let l40 = *ptr22.add(72).cast::<*mut u8>();
                                            let l41 = *ptr22.add(76).cast::<usize>();
                                            let len42 = l41;
                                            let l43 = i32::from(*ptr22.add(80).cast::<u8>());
                                            let l47 = *ptr22.add(92).cast::<*mut u8>();
                                            let l48 = *ptr22.add(96).cast::<usize>();
                                            let base64 = l47;
                                            let len64 = l48;
                                            let mut result64 = _rt::Vec::with_capacity(len64);
                                            for i in 0..len64 {
                                                let base = base64.add(i * 40);
                                                let e64 = {
                                                    let l49 = *base.add(0).cast::<*mut u8>();
                                                    let l50 = *base.add(4).cast::<usize>();
                                                    let len51 = l50;
                                                    let bytes51 = _rt::Vec::from_raw_parts(
                                                        l49.cast(),
                                                        len51,
                                                        len51,
                                                    );
                                                    let l52 = *base.add(8).cast::<*mut u8>();
                                                    let l53 = *base.add(12).cast::<usize>();
                                                    let len54 = l53;
                                                    let bytes54 = _rt::Vec::from_raw_parts(
                                                        l52.cast(),
                                                        len54,
                                                        len54,
                                                    );
                                                    let l55 = *base.add(16).cast::<*mut u8>();
                                                    let l56 = *base.add(20).cast::<usize>();
                                                    let len57 = l56;
                                                    let bytes57 = _rt::Vec::from_raw_parts(
                                                        l55.cast(),
                                                        len57,
                                                        len57,
                                                    );
                                                    let l58 = *base.add(24).cast::<*mut u8>();
                                                    let l59 = *base.add(28).cast::<usize>();
                                                    let len60 = l59;
                                                    let bytes60 = _rt::Vec::from_raw_parts(
                                                        l58.cast(),
                                                        len60,
                                                        len60,
                                                    );
                                                    let l61 = *base.add(32).cast::<*mut u8>();
                                                    let l62 = *base.add(36).cast::<usize>();
                                                    let len63 = l62;
                                                    let bytes63 = _rt::Vec::from_raw_parts(
                                                        l61.cast(),
                                                        len63,
                                                        len63,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes51),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes54),
                                                                package_name: _rt::string_lift(bytes57),
                                                                publisher_node: _rt::string_lift(bytes60),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes63),
                                                    }
                                                };
                                                result64.push(e64);
                                            }
                                            _rt::cabi_dealloc(base64, len64 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l37 as u8),
                                                expects_response: match l38 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l39 = *ptr22.add(64).cast::<i64>();
                                                            l39 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l40.cast(), len42, len42),
                                                metadata: match l43 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l44 = *ptr22.add(84).cast::<*mut u8>();
                                                            let l45 = *ptr22.add(88).cast::<usize>();
                                                            let len46 = l45;
                                                            let bytes46 = _rt::Vec::from_raw_parts(
                                                                l44.cast(),
                                                                len46,
                                                                len46,
                                                            );
                                                            _rt::string_lift(bytes46)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result64,
                                            }
                                        };
                                        Message::Request(e95)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e95 = {
                                            let l65 = i32::from(*ptr22.add(48).cast::<u8>());
                                            let l66 = *ptr22.add(52).cast::<*mut u8>();
                                            let l67 = *ptr22.add(56).cast::<usize>();
                                            let len68 = l67;
                                            let l69 = i32::from(*ptr22.add(60).cast::<u8>());
                                            let l73 = *ptr22.add(72).cast::<*mut u8>();
                                            let l74 = *ptr22.add(76).cast::<usize>();
                                            let base90 = l73;
                                            let len90 = l74;
                                            let mut result90 = _rt::Vec::with_capacity(len90);
                                            for i in 0..len90 {
                                                let base = base90.add(i * 40);
                                                let e90 = {
                                                    let l75 = *base.add(0).cast::<*mut u8>();
                                                    let l76 = *base.add(4).cast::<usize>();
                                                    let len77 = l76;
                                                    let bytes77 = _rt::Vec::from_raw_parts(
                                                        l75.cast(),
                                                        len77,
                                                        len77,
                                                    );
                                                    let l78 = *base.add(8).cast::<*mut u8>();
                                                    let l79 = *base.add(12).cast::<usize>();
                                                    let len80 = l79;
                                                    let bytes80 = _rt::Vec::from_raw_parts(
                                                        l78.cast(),
                                                        len80,
                                                        len80,
                                                    );
                                                    let l81 = *base.add(16).cast::<*mut u8>();
                                                    let l82 = *base.add(20).cast::<usize>();
                                                    let len83 = l82;
                                                    let bytes83 = _rt::Vec::from_raw_parts(
                                                        l81.cast(),
                                                        len83,
                                                        len83,
                                                    );
                                                    let l84 = *base.add(24).cast::<*mut u8>();
                                                    let l85 = *base.add(28).cast::<usize>();
                                                    let len86 = l85;
                                                    let bytes86 = _rt::Vec::from_raw_parts(
                                                        l84.cast(),
                                                        len86,
                                                        len86,
                                                    );
                                                    let l87 = *base.add(32).cast::<*mut u8>();
                                                    let l88 = *base.add(36).cast::<usize>();
                                                    let len89 = l88;
                                                    let bytes89 = _rt::Vec::from_raw_parts(
                                                        l87.cast(),
                                                        len89,
                                                        len89,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes77),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes80),
                                                                package_name: _rt::string_lift(bytes83),
                                                                publisher_node: _rt::string_lift(bytes86),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes89),
                                                    }
                                                };
                                                result90.push(e90);
                                            }
                                            _rt::cabi_dealloc(base90, len90 * 40, 4);
                                            let l91 = i32::from(*ptr22.add(80).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l65 as u8),
                                                    body: _rt::Vec::from_raw_parts(l66.cast(), len68, len68),
                                                    metadata: match l69 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l70 = *ptr22.add(64).cast::<*mut u8>();
                                                                let l71 = *ptr22.add(68).cast::<usize>();
                                                                let len72 = l71;
                                                                let bytes72 = _rt::Vec::from_raw_parts(
                                                                    l70.cast(),
                                                                    len72,
                                                                    len72,
                                                                );
                                                                _rt::string_lift(bytes72)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result90,
                                                },
                                                match l91 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l92 = *ptr22.add(84).cast::<*mut u8>();
                                                            let l93 = *ptr22.add(88).cast::<usize>();
                                                            let len94 = l93;
                                                            _rt::Vec::from_raw_parts(l92.cast(), len94, len94)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e95)
                                    }
                                };
                                (
                                    Address {
                                        node: _rt::string_lift(bytes26),
                                        process: ProcessId {
                                            process_name: _rt::string_lift(bytes29),
                                            package_name: _rt::string_lift(bytes32),
                                            publisher_node: _rt::string_lift(bytes35),
                                        },
                                    },
                                    v95,
                                )
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l96 = i32::from(*ptr22.add(8).cast::<u8>());
                                let l97 = *ptr22.add(12).cast::<*mut u8>();
                                let l98 = *ptr22.add(16).cast::<usize>();
                                let len99 = l98;
                                let bytes99 = _rt::Vec::from_raw_parts(
                                    l97.cast(),
                                    len99,
                                    len99,
                                );
                                let l100 = *ptr22.add(20).cast::<*mut u8>();
                                let l101 = *ptr22.add(24).cast::<usize>();
                                let len102 = l101;
                                let bytes102 = _rt::Vec::from_raw_parts(
                                    l100.cast(),
                                    len102,
                                    len102,
                                );
                                let l103 = *ptr22.add(28).cast::<*mut u8>();
                                let l104 = *ptr22.add(32).cast::<usize>();
                                let len105 = l104;
                                let bytes105 = _rt::Vec::from_raw_parts(
                                    l103.cast(),
                                    len105,
                                    len105,
                                );
                                let l106 = *ptr22.add(36).cast::<*mut u8>();
                                let l107 = *ptr22.add(40).cast::<usize>();
                                let len108 = l107;
                                let bytes108 = _rt::Vec::from_raw_parts(
                                    l106.cast(),
                                    len108,
                                    len108,
                                );
                                let l109 = i32::from(*ptr22.add(48).cast::<u8>());
                                let v168 = match l109 {
                                    0 => {
                                        let e168 = {
                                            let l110 = i32::from(*ptr22.add(56).cast::<u8>());
                                            let l111 = i32::from(*ptr22.add(64).cast::<u8>());
                                            let l113 = *ptr22.add(80).cast::<*mut u8>();
                                            let l114 = *ptr22.add(84).cast::<usize>();
                                            let len115 = l114;
                                            let l116 = i32::from(*ptr22.add(88).cast::<u8>());
                                            let l120 = *ptr22.add(100).cast::<*mut u8>();
                                            let l121 = *ptr22.add(104).cast::<usize>();
                                            let base137 = l120;
                                            let len137 = l121;
                                            let mut result137 = _rt::Vec::with_capacity(len137);
                                            for i in 0..len137 {
                                                let base = base137.add(i * 40);
                                                let e137 = {
                                                    let l122 = *base.add(0).cast::<*mut u8>();
                                                    let l123 = *base.add(4).cast::<usize>();
                                                    let len124 = l123;
                                                    let bytes124 = _rt::Vec::from_raw_parts(
                                                        l122.cast(),
                                                        len124,
                                                        len124,
                                                    );
                                                    let l125 = *base.add(8).cast::<*mut u8>();
                                                    let l126 = *base.add(12).cast::<usize>();
                                                    let len127 = l126;
                                                    let bytes127 = _rt::Vec::from_raw_parts(
                                                        l125.cast(),
                                                        len127,
                                                        len127,
                                                    );
                                                    let l128 = *base.add(16).cast::<*mut u8>();
                                                    let l129 = *base.add(20).cast::<usize>();
                                                    let len130 = l129;
                                                    let bytes130 = _rt::Vec::from_raw_parts(
                                                        l128.cast(),
                                                        len130,
                                                        len130,
                                                    );
                                                    let l131 = *base.add(24).cast::<*mut u8>();
                                                    let l132 = *base.add(28).cast::<usize>();
                                                    let len133 = l132;
                                                    let bytes133 = _rt::Vec::from_raw_parts(
                                                        l131.cast(),
                                                        len133,
                                                        len133,
                                                    );
                                                    let l134 = *base.add(32).cast::<*mut u8>();
                                                    let l135 = *base.add(36).cast::<usize>();
                                                    let len136 = l135;
                                                    let bytes136 = _rt::Vec::from_raw_parts(
                                                        l134.cast(),
                                                        len136,
                                                        len136,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes124),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes127),
                                                                package_name: _rt::string_lift(bytes130),
                                                                publisher_node: _rt::string_lift(bytes133),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes136),
                                                    }
                                                };
                                                result137.push(e137);
                                            }
                                            _rt::cabi_dealloc(base137, len137 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l110 as u8),
                                                expects_response: match l111 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l112 = *ptr22.add(72).cast::<i64>();
                                                            l112 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l113.cast(), len115, len115),
                                                metadata: match l116 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l117 = *ptr22.add(92).cast::<*mut u8>();
                                                            let l118 = *ptr22.add(96).cast::<usize>();
                                                            let len119 = l118;
                                                            let bytes119 = _rt::Vec::from_raw_parts(
                                                                l117.cast(),
                                                                len119,
                                                                len119,
                                                            );
                                                            _rt::string_lift(bytes119)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result137,
                                            }
                                        };
                                        Message::Request(e168)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e168 = {
                                            let l138 = i32::from(*ptr22.add(56).cast::<u8>());
                                            let l139 = *ptr22.add(60).cast::<*mut u8>();
                                            let l140 = *ptr22.add(64).cast::<usize>();
                                            let len141 = l140;
                                            let l142 = i32::from(*ptr22.add(68).cast::<u8>());
                                            let l146 = *ptr22.add(80).cast::<*mut u8>();
                                            let l147 = *ptr22.add(84).cast::<usize>();
                                            let base163 = l146;
                                            let len163 = l147;
                                            let mut result163 = _rt::Vec::with_capacity(len163);
                                            for i in 0..len163 {
                                                let base = base163.add(i * 40);
                                                let e163 = {
                                                    let l148 = *base.add(0).cast::<*mut u8>();
                                                    let l149 = *base.add(4).cast::<usize>();
                                                    let len150 = l149;
                                                    let bytes150 = _rt::Vec::from_raw_parts(
                                                        l148.cast(),
                                                        len150,
                                                        len150,
                                                    );
                                                    let l151 = *base.add(8).cast::<*mut u8>();
                                                    let l152 = *base.add(12).cast::<usize>();
                                                    let len153 = l152;
                                                    let bytes153 = _rt::Vec::from_raw_parts(
                                                        l151.cast(),
                                                        len153,
                                                        len153,
                                                    );
                                                    let l154 = *base.add(16).cast::<*mut u8>();
                                                    let l155 = *base.add(20).cast::<usize>();
                                                    let len156 = l155;
                                                    let bytes156 = _rt::Vec::from_raw_parts(
                                                        l154.cast(),
                                                        len156,
                                                        len156,
                                                    );
                                                    let l157 = *base.add(24).cast::<*mut u8>();
                                                    let l158 = *base.add(28).cast::<usize>();
                                                    let len159 = l158;
                                                    let bytes159 = _rt::Vec::from_raw_parts(
                                                        l157.cast(),
                                                        len159,
                                                        len159,
                                                    );
                                                    let l160 = *base.add(32).cast::<*mut u8>();
                                                    let l161 = *base.add(36).cast::<usize>();
                                                    let len162 = l161;
                                                    let bytes162 = _rt::Vec::from_raw_parts(
                                                        l160.cast(),
                                                        len162,
                                                        len162,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes150),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes153),
                                                                package_name: _rt::string_lift(bytes156),
                                                                publisher_node: _rt::string_lift(bytes159),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes162),
                                                    }
                                                };
                                                result163.push(e163);
                                            }
                                            _rt::cabi_dealloc(base163, len163 * 40, 4);
                                            let l164 = i32::from(*ptr22.add(88).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l138 as u8),
                                                    body: _rt::Vec::from_raw_parts(l139.cast(), len141, len141),
                                                    metadata: match l142 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l143 = *ptr22.add(72).cast::<*mut u8>();
                                                                let l144 = *ptr22.add(76).cast::<usize>();
                                                                let len145 = l144;
                                                                let bytes145 = _rt::Vec::from_raw_parts(
                                                                    l143.cast(),
                                                                    len145,
                                                                    len145,
                                                                );
                                                                _rt::string_lift(bytes145)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result163,
                                                },
                                                match l164 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l165 = *ptr22.add(92).cast::<*mut u8>();
                                                            let l166 = *ptr22.add(96).cast::<usize>();
                                                            let len167 = l166;
                                                            _rt::Vec::from_raw_parts(l165.cast(), len167, len167)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e168)
                                    }
                                };
                                let l169 = i32::from(*ptr22.add(112).cast::<u8>());
                                SendError {
                                    kind: SendErrorKind::_lift(l96 as u8),
                                    target: Address {
                                        node: _rt::string_lift(bytes99),
                                        process: ProcessId {
                                            process_name: _rt::string_lift(bytes102),
                                            package_name: _rt::string_lift(bytes105),
                                            publisher_node: _rt::string_lift(bytes108),
                                        },
                                    },
                                    message: v168,
                                    lazy_load_blob: match l169 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l170 = i32::from(*ptr22.add(116).cast::<u8>());
                                                let l174 = *ptr22.add(128).cast::<*mut u8>();
                                                let l175 = *ptr22.add(132).cast::<usize>();
                                                let len176 = l175;
                                                LazyLoadBlob {
                                                    mime: match l170 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l171 = *ptr22.add(120).cast::<*mut u8>();
                                                                let l172 = *ptr22.add(124).cast::<usize>();
                                                                let len173 = l172;
                                                                let bytes173 = _rt::Vec::from_raw_parts(
                                                                    l171.cast(),
                                                                    len173,
                                                                    len173,
                                                                );
                                                                _rt::string_lift(bytes173)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    bytes: _rt::Vec::from_raw_parts(l174.cast(), len176, len176),
                                                }
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
        }
        #[allow(dead_code, clippy::all)]
        pub mod id {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Address = super::super::super::hyperware::process::standard::Address;
            /// Function signature for: sign (http)
            pub struct SignSignatureHttp {
                pub message: _rt::Vec<u8>,
                pub returning: Result<_rt::Vec<u8>, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SignSignatureHttp {
                #[inline]
                fn clone(&self) -> SignSignatureHttp {
                    SignSignatureHttp {
                        message: ::core::clone::Clone::clone(&self.message),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<SignSignatureHttp> for Vec<u8> {
                fn from(value: SignSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a SignSignatureHttp> for Vec<u8> {
                fn from(value: &'a SignSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for SignSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for SignSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SignSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "message" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"message" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SignSignatureHttp>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SignSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct SignSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct SignSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::Vec<u8>, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct SignSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(SignSignatureHttp {
                                    message: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<_rt::Vec<u8>, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "message",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::Vec<u8>, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("message")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(SignSignatureHttp {
                                    message: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "message",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "SignSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SignSignatureHttp>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SignSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "SignSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "message",
                            &self.message,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for SignSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SignSignatureHttp")
                        .field("message", &self.message)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: verify (http)
            pub struct VerifySignatureHttp {
                pub message: _rt::Vec<u8>,
                pub signature: _rt::Vec<u8>,
                pub returning: Result<bool, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for VerifySignatureHttp {
                #[inline]
                fn clone(&self) -> VerifySignatureHttp {
                    VerifySignatureHttp {
                        message: ::core::clone::Clone::clone(&self.message),
                        signature: ::core::clone::Clone::clone(&self.signature),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<VerifySignatureHttp> for Vec<u8> {
                fn from(value: VerifySignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a VerifySignatureHttp> for Vec<u8> {
                fn from(value: &'a VerifySignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for VerifySignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for VerifySignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for VerifySignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "message" => _serde::__private::Ok(__Field::__field0),
                                    "signature" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"message" => _serde::__private::Ok(__Field::__field0),
                                    b"signature" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<VerifySignatureHttp>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = VerifySignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct VerifySignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct VerifySignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct VerifySignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<bool, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct VerifySignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(VerifySignatureHttp {
                                    message: __field0,
                                    signature: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<bool, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "message",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "signature",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<bool, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("message")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("signature")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(VerifySignatureHttp {
                                    message: __field0,
                                    signature: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "message",
                            "signature",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "VerifySignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    VerifySignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for VerifySignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "VerifySignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "message",
                            &self.message,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "signature",
                            &self.signature,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for VerifySignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("VerifySignatureHttp")
                        .field("message", &self.message)
                        .field("signature", &self.signature)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if true {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if true {
            match val {
                0 => false,
                1 => true,
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("invalid bool discriminant"),
                    );
                }
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if true {
            {
                ::core::panicking::panic_fmt(format_args!("invalid enum discriminant"));
            }
        } else {
            core::hint::unreachable_unchecked()
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub use alloc_crate::alloc;
    extern crate alloc as alloc_crate;
}
#[doc(inline)]
pub(crate) use __export_id_sys_v0_impl as export;
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
}
const _: &[u8] = b"package hyperware:process@1.0.0;\n\ninterface standard {\n\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    System Types\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// JSON is passed over Wasm boundary as a string.\n    type json = string;\n\n    /// In types passed from kernel, node-id will be a valid Kimap entry.\n    type node-id = string;\n\n    /// Context, like a message body, is a protocol-defined serialized byte\n    /// array. It is used when building a Request to save information that\n    /// will not be part of a Response, in order to more easily handle\n    /// (\"contextualize\") that Response.\n    type context = list<u8>;\n\n    record process-id {\n        process-name: string,\n        package-name: string,\n        publisher-node: node-id,\n    }\n\n    record package-id {\n        package-name: string,\n        publisher-node: node-id,\n    }\n\n    record address {\n        node: node-id,\n        process: process-id,\n    }\n\n    record lazy-load-blob {\n        mime: option<string>,\n        bytes: list<u8>,\n    }\n\n    record request {\n        // set in order to inherit lazy-load-blob from parent message, and if\n        // expects-response is none, direct response to source of parent.\n        // also carries forward certain aspects of parent message in kernel,\n        // see documentation for formal spec and examples:\n        // https://docs.rs/hyperware_process_lib/latest/hyperware_process_lib/struct.Request.html\n        inherit: bool,\n        // if some, request expects a response in the given number of seconds\n        expects-response: option<u64>,\n        body: list<u8>,\n        metadata: option<json>,\n        capabilities: list<capability>,\n        // to grab lazy-load-blob, use get_blob()\n    }\n\n    record response {\n        inherit: bool,\n        body: list<u8>,\n        metadata: option<json>,\n        capabilities: list<capability>,\n        // to grab lazy-load-blob, use get_blob()\n    }\n\n    /// A message can be a request or a response. Within a response, there is\n    /// a result which surfaces any error that happened because of a request.\n    /// A successful response will contain the context of the request it\n    /// matches, if any was set.\n    variant message {\n        request(request),\n        response(tuple<response, option<context>>),\n    }\n\n    record capability {\n        issuer: address,\n        params: json,\n    }\n\n    /// On-exit is a setting that determines what happens when a process\n    /// panics, completes, or otherwise \"ends\".\n    /// NOTE: requests will always have expects-response set to false by kernel.\n    variant on-exit {\n        none,\n        restart,\n        requests(list<tuple<address, request, option<lazy-load-blob>>>),\n    }\n\n    /// Send errors come from trying to send a message to another process,\n    /// either locally or on another node.\n    /// A message can fail by timing out, or by the node being entirely\n    /// unreachable (offline or can\'t be found in PKI). In either case,\n    /// the message is not delivered and the process that sent it receives\n    /// that message back along with any assigned context and/or lazy-load-blob,\n    /// and is free to handle it as it sees fit.\n    /// In the local case, only timeout errors are possible and also cover the case\n    /// in which a process is not running or does not exist.\n    record send-error {\n        kind: send-error-kind,\n        target: address,\n        message: message,\n        lazy-load-blob: option<lazy-load-blob>,\n    }\n\n    enum send-error-kind {\n        offline,\n        timeout,\n    }\n\n    enum spawn-error {\n        name-taken,\n        no-file-at-path,\n    }\n\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    System Utils\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// Prints to the terminal at a given verbosity level.\n    /// Higher verbosity levels print more information.\n    /// Level 0 is always printed -- use sparingly.\n    print-to-terminal: func(verbosity: u8, message: string);\n\n    /// Returns the address of the process.\n    our: func() -> address;\n\n    //        \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    Process Management\n    //        \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    get-on-exit: func() -> on-exit;\n\n    set-on-exit: func(on-exit: on-exit);\n\n    get-state: func() -> option<list<u8>>;\n\n    set-state: func(bytes: list<u8>);\n\n    clear-state: func();\n\n    spawn: func(\n        // name is optional. if not provided, name will be a random u64.\n        name: option<string>,\n        // wasm-path must be located within package\'s drive\n        wasm-path: string,\n        on-exit: on-exit,\n        // requested capabilities must be owned by the caller\n        request-capabilities: list<capability>,\n        // granted capabilities will be generated by the child process\n        // and handed out to the indicated process-id.\n        grant-capabilities: list<tuple<process-id, json>>,\n        public: bool\n    ) -> result<process-id, spawn-error>;\n\n    //           \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    Capabilities Management\n    //           \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// Saves the capabilities to persisted process state.\n    save-capabilities: func(caps: list<capability>);\n\n    /// Deletes the capabilities from persisted process state.\n    drop-capabilities: func(caps: list<capability>);\n\n    /// Gets all capabilities from persisted process state.\n    our-capabilities: func() -> list<capability>;\n\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    Message I/O\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// Ingest next message when it arrives along with its source.\n    /// Almost all long-running processes will call this in a loop.\n    receive: func() ->\n        result<tuple<address, message>, tuple<send-error, option<context>>>;\n\n    /// Returns whether or not the current message has a blob.\n    has-blob: func() -> bool;\n\n    /// Returns the blob of the current message, if any.\n    get-blob: func() -> option<lazy-load-blob>;\n\n    /// Returns the last blob this process received.\n    last-blob: func() -> option<lazy-load-blob>;\n\n    /// Send request to target.\n    send-request: func(\n        target: address,\n        request: request,\n        context: option<context>,\n        lazy-load-blob: option<lazy-load-blob>\n    );\n\n    /// Send requests to targets.\n    send-requests: func(\n        requests: list<tuple<address,\n                             request,\n                             option<context>,\n                             option<lazy-load-blob>>>\n    );\n\n    /// Send response to the request currently being handled.\n    send-response: func(\n        response: response,\n        lazy-load-blob: option<lazy-load-blob>\n    );\n\n    /// Send a single request, then block (internally) until its response. The\n    /// type returned is Message but will always contain Response.\n    send-and-await-response: func(\n        target: address,\n        request: request,\n        lazy-load-blob: option<lazy-load-blob>\n    ) -> result<tuple<address, message>, send-error>;\n}\n\nworld lib {\n    import standard;\n}\n\nworld process-v1 {\n    include lib;\n\n    export init: func(our: string);\n}\n";
const _: &[u8] = b"world types-sign-sys-v0 {\n    import sign;\n    include lib;\n}";
const _: &[u8] = b"world types {\n    include types-sign-sys-v0;\n    include types-id-sys-v0;\n}\n";
const _: &[u8] = b"interface id {\n    // This interface contains function signature definitions that will be used\n    // by the hyper-bindgen macro to generate async function bindings.\n    //\n    // NOTE: This is currently a hacky workaround since WIT async functions are not\n    // available until WASI Preview 3. Once Preview 3 is integrated into Hyperware,\n    // we should switch to using proper async WIT function signatures instead of\n    // this struct-based approach with hyper-bindgen generating the async stubs.\n\n    use standard.{address};\n\n    // Function signature for: sign (http)\n    record sign-signature-http {\n        message: list<u8>,\n        returning: result<list<u8>, string>\n    }\n\n    // Function signature for: verify (http)\n    record verify-signature-http {\n        message: list<u8>,\n        signature: list<u8>,\n        returning: result<bool, string>\n    }\n}\n";
const _: &[u8] = b"world id-sys-v0 {\n    import id;\n    include process-v1;\n}";
const _: &[u8] = b"world sign-sys-v0 {\n    import sign;\n    include process-v1;\n}";
const _: &[u8] = b"world types-id-sys-v0 {\n    import id;\n    include lib;\n}";
const _: &[u8] = b"interface sign {\n    // This interface contains function signature definitions that will be used\n    // by the hyper-bindgen macro to generate async function bindings.\n    //\n    // NOTE: This is currently a hacky workaround since WIT async functions are not\n    // available until WASI Preview 3. Once Preview 3 is integrated into Hyperware,\n    // we should switch to using proper async WIT function signatures instead of\n    // this struct-based approach with hyper-bindgen generating the async stubs.\n\n    use standard.{address};\n\n    // Function signature for: sign (local)\n    record sign-signature-local {\n        target: address,\n        message: list<u8>,\n        returning: result<list<u8>, string>\n    }\n\n    // Function signature for: verify (local)\n    record verify-signature-local {\n        target: address,\n        message: list<u8>,\n        signature: list<u8>,\n        returning: result<bool, string>\n    }\n}\n";
use hyperware_app_common::hyperware_process_lib as hyperware_process_lib;
use hyperware_process_lib::http::server::HttpBindingConfig;
use hyperware_process_lib::http::server::WsBindingConfig;
use hyperware_app_common::Binding;
impl IdState {
    async fn init(&mut self) {
        init_logging(Level::DEBUG, Level::INFO, None, None, None).unwrap();
    }
    async fn sign(&mut self, message: Vec<u8>) -> Result<Vec<u8>, String> {
        let target = make_sign_sys();
        match sign_local_rpc(&target, message).await {
            Ok(r) => r,
            _ => Err("oops".to_string()),
        }
    }
    async fn verify(
        &mut self,
        message: Vec<u8>,
        signature: Vec<u8>,
    ) -> Result<bool, String> {
        let target = make_sign_sys();
        match verify_local_rpc(&target, message, signature).await {
            Ok(r) => r,
            _ => Err("oops".to_string()),
        }
    }
}
enum HPMRequest {
    Sign(Vec<u8>),
    Verify(Vec<u8>, Vec<u8>),
}
#[automatically_derived]
impl ::core::fmt::Debug for HPMRequest {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            HPMRequest::Sign(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Sign", &__self_0)
            }
            HPMRequest::Verify(__self_0, __self_1) => {
                ::core::fmt::Formatter::debug_tuple_field2_finish(
                    f,
                    "Verify",
                    __self_0,
                    &__self_1,
                )
            }
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for HPMRequest {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                HPMRequest::Sign(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        0u32,
                        "Sign",
                        __field0,
                    )
                }
                HPMRequest::Verify(ref __field0, ref __field1) => {
                    let mut __serde_state = _serde::Serializer::serialize_tuple_variant(
                        __serializer,
                        "HPMRequest",
                        1u32,
                        "Verify",
                        0 + 1 + 1,
                    )?;
                    _serde::ser::SerializeTupleVariant::serialize_field(
                        &mut __serde_state,
                        __field0,
                    )?;
                    _serde::ser::SerializeTupleVariant::serialize_field(
                        &mut __serde_state,
                        __field1,
                    )?;
                    _serde::ser::SerializeTupleVariant::end(__serde_state)
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for HPMRequest {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "Sign" => _serde::__private::Ok(__Field::__field0),
                        "Verify" => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"Sign" => _serde::__private::Ok(__Field::__field0),
                        b"Verify" => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<HPMRequest>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = HPMRequest;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum HPMRequest",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Vec<u8>,
                                >(__variant),
                                HPMRequest::Sign,
                            )
                        }
                        (__Field::__field1, __variant) => {
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "tuple variant HPMRequest::Verify",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match _serde::de::SeqAccess::next_element::<
                                        Vec<u8>,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    0usize,
                                                    &"tuple variant HPMRequest::Verify with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    let __field1 = match _serde::de::SeqAccess::next_element::<
                                        Vec<u8>,
                                    >(&mut __seq)? {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"tuple variant HPMRequest::Verify with 2 elements",
                                                ),
                                            );
                                        }
                                    };
                                    _serde::__private::Ok(
                                        HPMRequest::Verify(__field0, __field1),
                                    )
                                }
                            }
                            _serde::de::VariantAccess::tuple_variant(
                                __variant,
                                2usize,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &["Sign", "Verify"];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "HPMRequest",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<HPMRequest>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
enum HPMResponse {
    Sign(Result<Vec<u8>, String>),
    Verify(Result<bool, String>),
}
#[automatically_derived]
impl ::core::fmt::Debug for HPMResponse {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            HPMResponse::Sign(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Sign", &__self_0)
            }
            HPMResponse::Verify(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Verify", &__self_0)
            }
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for HPMResponse {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                HPMResponse::Sign(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        0u32,
                        "Sign",
                        __field0,
                    )
                }
                HPMResponse::Verify(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        1u32,
                        "Verify",
                        __field0,
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for HPMResponse {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "Sign" => _serde::__private::Ok(__Field::__field0),
                        "Verify" => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"Sign" => _serde::__private::Ok(__Field::__field0),
                        b"Verify" => _serde::__private::Ok(__Field::__field1),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<HPMResponse>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = HPMResponse;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum HPMResponse",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<Vec<u8>, String>,
                                >(__variant),
                                HPMResponse::Sign,
                            )
                        }
                        (__Field::__field1, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<bool, String>,
                                >(__variant),
                                HPMResponse::Verify,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &["Sign", "Verify"];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "HPMResponse",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<HPMResponse>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
/// Handle messages from the HTTP server
fn handle_http_server_message(
    state: *mut IdState,
    message: hyperware_process_lib::Message,
) {
    match serde_json::from_slice::<
        hyperware_process_lib::http::server::HttpServerRequest,
    >(message.body()) {
        Ok(http_server_request) => {
            match http_server_request {
                hyperware_process_lib::http::server::HttpServerRequest::Http(
                    http_request,
                ) => {
                    hyperware_app_common::APP_CONTEXT
                        .with(|ctx| {
                            ctx.borrow_mut().current_path = Some(
                                http_request
                                    .path()
                                    .clone()
                                    .expect("Failed to get path from HTTP request"),
                            );
                        });
                    let Some(blob) = message.blob() else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event id/src/lib.rs:13",
                                        "id",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "id/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(13u32),
                                        ::tracing_core::__macro_support::Option::Some("id"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "Failed to get blob for HTTP, sending BAD_REQUEST",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        hyperware_process_lib::http::server::send_response(
                            hyperware_process_lib::http::StatusCode::BAD_REQUEST,
                            None,
                            ::alloc::vec::Vec::new(),
                        );
                        return;
                    };
                    match serde_json::from_slice::<HPMRequest>(&blob.bytes) {
                        Ok(request) => {
                            unsafe {
                                match request {
                                    HPMRequest::Sign(param) => {
                                        let param_captured = param;
                                        let state_ptr: *mut IdState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).sign(param_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::Verify(param0, param1) => {
                                        let param0_captured = param0;
                                        let param1_captured = param1;
                                        let state_ptr: *mut IdState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).verify(param0_captured, param1_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!(
                                                    "Non-http request variant received in http handler",
                                                ),
                                            ),
                                        );
                                    }
                                }
                                hyperware_app_common::maybe_save_state(&mut *state);
                            }
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event id/src/lib.rs:13",
                                            "id",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "id/src/lib.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(13u32),
                                            ::tracing_core::__macro_support::Option::Some("id"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Failed to deserialize HTTP request into HPMRequest enum: {0}\n{1:?}",
                                                                e,
                                                                serde_json::from_slice::<serde_json::Value>(&blob.bytes),
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            hyperware_process_lib::http::server::send_response(
                                hyperware_process_lib::http::StatusCode::BAD_REQUEST,
                                None,
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Invalid request format: {0}", e),
                                        );
                                        res
                                    })
                                    .into_bytes(),
                            );
                        }
                    }
                    hyperware_app_common::APP_CONTEXT
                        .with(|ctx| {
                            ctx.borrow_mut().current_path = None;
                        });
                }
                hyperware_process_lib::http::server::HttpServerRequest::WebSocketPush {
                    channel_id,
                    message_type,
                } => {
                    let Some(blob) = message.blob() else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event id/src/lib.rs:13",
                                        "id",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "id/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(13u32),
                                        ::tracing_core::__macro_support::Option::Some("id"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "Failed to get blob for WebSocketPush, exiting",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        return;
                    };
                    unsafe {
                        hyperware_app_common::maybe_save_state(&mut *state);
                    }
                }
                hyperware_process_lib::http::server::HttpServerRequest::WebSocketOpen {
                    path,
                    channel_id,
                } => {
                    hyperware_app_common::get_server()
                        .unwrap()
                        .handle_websocket_open(&path, channel_id);
                }
                hyperware_process_lib::http::server::HttpServerRequest::WebSocketClose(
                    channel_id,
                ) => {
                    hyperware_app_common::get_server()
                        .unwrap()
                        .handle_websocket_close(channel_id);
                }
            }
        }
        Err(e) => {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event id/src/lib.rs:13",
                            "id",
                            ::tracing::Level::WARN,
                            ::tracing_core::__macro_support::Option::Some(
                                "id/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(13u32),
                            ::tracing_core::__macro_support::Option::Some("id"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::WARN
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::WARN
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("Failed to parse HTTP server request: {0}", e)
                                                as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
    }
}
/// Handle local messages
fn handle_local_message(state: *mut IdState, message: hyperware_process_lib::Message) {
    match serde_json::from_slice::<serde_json::Value>(message.body()) {
        Ok(req_value) => {
            match serde_json::from_value::<HPMRequest>(req_value.clone()) {
                Ok(request) => {
                    unsafe {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event id/src/lib.rs:13",
                                        "id",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "id/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(13u32),
                                        ::tracing_core::__macro_support::Option::Some("id"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "No local handlers defined but received a local request",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        hyperware_app_common::maybe_save_state(&mut *state);
                    }
                }
                Err(e) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event id/src/lib.rs:13",
                                    "id",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "id/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(13u32),
                                    ::tracing_core::__macro_support::Option::Some("id"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Failed to deserialize local request into HPMRequest enum: {0}",
                                                        e,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
            }
        }
        Err(e) => {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event id/src/lib.rs:13",
                            "id",
                            ::tracing::Level::WARN,
                            ::tracing_core::__macro_support::Option::Some(
                                "id/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(13u32),
                            ::tracing_core::__macro_support::Option::Some("id"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::WARN
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::WARN
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "Failed to parse message body as JSON: {0}",
                                                e,
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
    }
}
/// Handle remote messages
fn handle_remote_message(state: *mut IdState, message: hyperware_process_lib::Message) {
    match serde_json::from_slice::<serde_json::Value>(message.body()) {
        Ok(req_value) => {
            match serde_json::from_value::<HPMRequest>(req_value.clone()) {
                Ok(request) => {
                    unsafe {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event id/src/lib.rs:13",
                                        "id",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "id/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(13u32),
                                        ::tracing_core::__macro_support::Option::Some("id"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "No remote handlers defined but received a remote request",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        hyperware_app_common::maybe_save_state(&mut *state);
                    }
                }
                Err(e) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event id/src/lib.rs:13",
                                    "id",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "id/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(13u32),
                                    ::tracing_core::__macro_support::Option::Some("id"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Failed to deserialize remote request into HPMRequest enum: {0}",
                                                        e,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event id/src/lib.rs:13",
                                    "id",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "id/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(13u32),
                                    ::tracing_core::__macro_support::Option::Some("id"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!("Raw request value: {0:?}", req_value)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
            }
        }
        Err(e) => {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event id/src/lib.rs:13",
                            "id",
                            ::tracing::Level::WARN,
                            ::tracing_core::__macro_support::Option::Some(
                                "id/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(13u32),
                            ::tracing_core::__macro_support::Option::Some("id"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::WARN
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::WARN
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "Failed to parse message body as JSON: {0}",
                                                e,
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
    }
}
struct Component;
impl Guest for Component {
    fn init(_our: String) {
        let mut state = hyperware_app_common::initialize_state::<IdState>();
        let app_name = "id";
        let app_icon = None;
        let app_widget = None;
        let ui_config = Some(HttpBindingConfig::default());
        let endpoints = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                Binding::Http {
                    path: "/api",
                    config: HttpBindingConfig::default(),
                },
                Binding::Ws {
                    path: "/ws",
                    config: WsBindingConfig::default(),
                },
            ]),
        );
        if app_icon.is_some() && app_widget.is_some() {
            hyperware_process_lib::homepage::add_to_homepage(
                app_name,
                app_icon,
                Some("/"),
                app_widget,
            );
        }
        let mut server = hyperware_app_common::setup_server(
            ui_config.as_ref(),
            &endpoints,
        );
        hyperware_app_common::APP_CONTEXT
            .with(|ctx| {
                ctx.borrow_mut().current_server = Some(&mut server);
            });
        if Some("init").is_some() {
            let state_ptr: *mut IdState = &mut state;
            ::hyperware_app_common::APP_CONTEXT
                .with(|ctx| {
                    ctx.borrow_mut()
                        .executor
                        .spawn(async move {
                            unsafe { (*state_ptr).init().await };
                        })
                })
        }
        loop {
            hyperware_app_common::APP_CONTEXT
                .with(|ctx| {
                    ctx.borrow_mut().executor.poll_all_tasks();
                });
            match hyperware_process_lib::await_message() {
                Ok(message) => {
                    CURRENT_MESSAGE
                        .with(|cell| {
                            *cell.borrow_mut() = Some(message.clone());
                        });
                    match message {
                        hyperware_process_lib::Message::Response {
                            body,
                            context,
                            ..
                        } => {
                            let correlation_id = context
                                .as_deref()
                                .map(|bytes| String::from_utf8_lossy(bytes).to_string())
                                .unwrap_or_else(|| "no context".to_string());
                            hyperware_app_common::RESPONSE_REGISTRY
                                .with(|registry| {
                                    let mut registry_mut = registry.borrow_mut();
                                    registry_mut.insert(correlation_id, body);
                                });
                        }
                        hyperware_process_lib::Message::Request { .. } => {
                            if message.is_local()
                                && message.source().process == "http-server:distro:sys"
                            {
                                handle_http_server_message(&mut state, message);
                            } else if message.is_local() {
                                handle_local_message(&mut state, message);
                            } else {
                                handle_remote_message(&mut state, message);
                            }
                        }
                    }
                }
                Err(ref error) => {
                    if let hyperware_process_lib::SendError {
                        context: Some(context),
                        ..
                    } = error {
                        let correlation_id = String::from_utf8_lossy(context)
                            .to_string();
                        hyperware_app_common::RESPONSE_REGISTRY
                            .with(|registry| {
                                let mut registry_mut = registry.borrow_mut();
                                registry_mut
                                    .insert(correlation_id, serde_json::to_vec(error).unwrap());
                            });
                    }
                }
            }
        }
    }
}
const _: () = {
    #[export_name = "init"]
    unsafe extern "C" fn export_init(arg0: *mut u8, arg1: usize) {
        self::_export_init_cabi::<Component>(arg0, arg1)
    }
};
